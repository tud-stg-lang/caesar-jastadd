/*
 * Adapts byte code creation for conditional constructors
 *
 * (1) In constructor accesses, don't cast to the target parameter type if there is no
 *     matching constructor.
 * (2) For constructor declarations, save additional information about the invocation of
 *     a "this" or "super" constructor in form of an attribute.
 * (3) Separate multiple arguments when calling the super or another this constructor by
 *     NOPs. Don't write anything but the arguments to the bytecode for the constructor
 *     access. Anything else that is needed will be generated during loading.
 * (4) Write accesses to concrete constructor parameters correctly.
 * (5) Don't cast arguments in calls to CJ constructors because they might be unknown at
 *     compile time.
 * (6) For constructor calls due to class instance expressions, just assume existence of
 *     matching constructor and write an appropriate constructor call.
 */
aspect CCCreateBCode {

	// Aspect goal (1)
	refine CreateBCode protected void ConstructorAccess.emitCastToIthParameterIfPossible(CodeGeneration gen, int i) {
		if (!decl().equals(unknownConstructor()))
			getArg(i).type().emitCastTo(gen, decl().getParameter(i).type()); // MethodInvocationConversion
	}

	// Aspect goal (2)
	/**
	 * Attribute to be added to constructors in order to save constructor parameter patterns
	 * @see org.caesarj.runtime.mixer.ConditionalConstructorAttribute
	 */
	class ConditionalConstructorAttribute extends Attribute {
	
		public ConditionalConstructorAttribute(CondConstructorDecl decl) {
			super(
				decl.hostType().constantPool(),
				org.caesarj.runtime.mixer.ConditionalConstructorAttribute.ATTRIBUTE_NAME);
			Stmt constructorInvocation = decl.getConstructorInvocation();
			if (!(constructorInvocation instanceof ExprStmt))
				return;
			Expr expr = ((ExprStmt) constructorInvocation).getExpr();
			if (!(expr instanceof CondConstructorAccess))
				return;
	
			final ConstantPool pool = decl.hostType().constantPool();
	
			/*
			 * Write formal parameters of this constructor:
			 */
			u1(org.caesarj.runtime.mixer.ConditionalConstructorAttribute.PARAMETER_PATTERN_LIST);
			int numArg = decl.getConstructorParameters().getNumChild();
			u1(numArg);
			final java.util.List<String> listIds = new ArrayList<String>();
			for (ConstructorParameterDeclaration param : decl
					.getConstructorParameters()) {
				param.writeToAttribute(this, pool);
				if (param instanceof ListConstructorParameterDeclaration)
					listIds.add(((ListConstructorParameterDeclaration) param).getID());
			}
	
			/*
			 * Write argument pattern which is passed to the other constructor:
			 */
			CondConstructorAccess access = (CondConstructorAccess) expr;
			u1(org.caesarj.runtime.mixer.ConditionalConstructorAttribute.PARAMETER_PATTERN_LIST);
			numArg = access.getNumArg();
			u1(numArg);
			for (CondConstructorArgument arg : access.getArgs())
				arg.writeToAttribute(this, pool, listIds);
	
			/*
			 * Write 1 if a super constructor is called, 0 if a this constructor is called.
			 */
			u1(access instanceof CondSuperConstructorAccess ? 1 : 0);
		}
	}

	// Aspect goal (2)
	eq CondConstructorDecl.attributes() {
		Collection c = super.attributes();
		c.add(new ConditionalConstructorAttribute(this));
		return c;
	}
	
	// Aspect goal (2)
	protected abstract void CondConstructorArgument.writeToAttribute(Attribute attribute,
			ConstantPool pool, java.util.List<String> listNames);
	
	// Aspect goal (2)
	protected void ExprCondConstructorArgument.writeToAttribute(Attribute attribute,
			ConstantPool pool, java.util.List<String> listNames) {
		attribute.u1(org.caesarj.runtime.mixer.ConditionalConstructorAttribute.PARAMETER_PATTERN_CONCRETE);
		attribute.u2(pool.addUtf8("")); // name
		attribute.u2(pool.addUtf8(getExpr().type().signature())); // type signature
	}
	
	// Aspect goal (2)
	protected void ListCondConstructorArgument.writeToAttribute(Attribute attribute,
			ConstantPool pool, java.util.List<String> listNames) {
		attribute.u1(org.caesarj.runtime.mixer.ConditionalConstructorAttribute.PARAMETER_LIST_PATTERN);
		attribute.u1(listNames.indexOf(getID())); // index of referenced formal parameter, unused here
	}
	
	// Aspect goal (2)
	protected abstract void ConstructorParameterDeclaration.writeToAttribute(Attribute attribute,
			ConstantPool pool);
	
	// Aspect goal (2)
	protected void FormalConstructorParameterDeclaration.writeToAttribute(Attribute attribute,
			ConstantPool pool) {
		attribute.u1(org.caesarj.runtime.mixer.ConditionalConstructorAttribute.PARAMETER_PATTERN_CONCRETE);
		attribute.u2(pool.addUtf8(getParameterDeclaration().getID())); // name
		attribute.u2(pool.addUtf8(getParameterDeclaration().getTypeAccess().type().signature())); // type signature
	}
	
	// Aspect goal (2)
	protected void ListConstructorParameterDeclaration.writeToAttribute(Attribute attribute,
			ConstantPool pool) {
		attribute.u1(org.caesarj.runtime.mixer.ConditionalConstructorAttribute.PARAMETER_LIST_PATTERN);
		attribute.u1(0); // index of referenced formal parameter, unused here
	}
	
	// Aspect goal (3)
	// also see org.caesarj.runtime.mixer.ConstructorMixer#separateInstructions(MethodNode)
	public void CondConstructorAccess.createBCode(CodeGeneration gen) {
		// args
		for (CondConstructorArgument arg : getArgs()) {
			if (!(arg instanceof ExprCondConstructorArgument))
				continue;
			((ExprCondConstructorArgument) arg).getExpr().createBCode(gen);
			gen.emit(Bytecode.NOP);
		}
		gen.emit(Bytecode.NOP);
	}
	
	eq CondConstructorAccess.needsPop() = false;

	// Aspect goal (4)
	refine MCFieldAccess public void VarAccess.createBCode(CodeGeneration gen) {
		Variable v = decl();
		if (!(v instanceof FormalConstructorParameterDeclaration)) {
			MCFieldAccess.VarAccess.createBCode(gen);
			return;
		}
		if (v.hostType() == hostType())
			v.type().emitLoadLocal(gen,
					((FormalConstructorParameterDeclaration) v).localNum());
		else
			emitLoadLocalInNestedClass(gen, v);
	}
	
	// Aspect goal (5)
	refine MCConstructors private void CjClassInstanceExpr.emitArg(CodeGeneration gen, int i) {
		getArg(i).createBCode(gen);
		// don't cast to target method
	}
	
	// Aspect goal (6)
	refine MCConstructors public void CjClassInstanceExpr.createBCode(CodeGeneration gen) {
		type().emitNew(gen);
		type().emitDup(gen);

		for (int i = 0; i < getNumArg(); ++i)
			emitArg(gen, i);

		int size = -1;
		for (int i = 0; i < getNumArg(); i++)
			size -= getArg(i).type().variableSize();
		int index = gen.constantPool().addMethodref(type().constantPoolName(),
				"<init>", constructorDesc());
		gen.emit(Bytecode.INVOKESPECIAL, size).add2(index);
  	}
  	
  	syn lazy String CjClassInstanceExpr.constructorDesc() {
		StringBuffer b = new StringBuffer();
		b.append("(");
		// this$0
		// args
		b.append("Lorg/caesarj/runtime/CjObjectIfc;");
		for (int i = 1; i < getNumArg(); i++) {
			TypeDecl type = getArg(i).type();
			if (type.isNull())
				b.append("Ljava/lang/Object;");
			else
				b.append(type.typeDescriptor());
		}
		b.append(")V");
		return b.toString();
	}

}