/*
 * Adapts error checking to conditional constructors
 *
 * (1) If a constructor pattern does not match any constructor of the superclass, no
 *     error, but only a warning is produced.
 * (2) If multiple constructors with the same signatures are defined within a class,
 *     only throw an error if they call the same super constructor.
 */
aspect CCErrorCheck {

	// Aspect goal (1)	 
	refine NameCheck public void ConstructorAccess.nameCheck() {
	    super.nameCheck();
	    if(decls().isEmpty())
	      warning("no constructor named " + this);
	    if(decls().size() > 1 && validArgs()) {
	      error("several most specific constructors for " + this);
	      for(Iterator iter = decls().iterator(); iter.hasNext(); ) {
	        error("         " + ((ConstructorDecl)iter.next()).signature());
	      }
	    }
	}
	
	// Aspect goal (2)
	refine NameCheck public void ConstructorDecl.nameCheck() {
	    super.nameCheck();
		// 8.8
		if (!hostType().name().equals(name()))
			error("constructor "
					+ name()
					+ " does not have the same name as the simple name of the host class "
					+ hostType().name());

		// 8.8.2
		ConstructorDecl thatConstructor = hostType().lookupConstructor(this);
		if (thatConstructor != this
				&& (!(this instanceof CondConstructorDecl) ||
				    getConstructorAccess() == null && thatConstructor.getConstructorAccess() == null ||
				    getConstructorAccess() != null && getConstructorAccess()
						.sameSignature(thatConstructor.getConstructorAccess())))
			error("constructor with signature " + signature()
					+ " is multiply declared in type " + hostType().typeName());

		if (circularThisInvocation(this))
			error("The constructor " + signature()
					+ " may not directly or indirectly invoke itself");
	}
	
}