/*
 * Adapt name checks to conditional constructors.
 *
 * (1) Don't check ParameterDeclarations contained in FormalConstructorParameterDeclarations
 *     the usual way.
 * (2) Make sure that constructor parameters are not assigned names which are already
 *     existing.
 * (3) Produce an error if a normal constructor calls a conditional constructor.
 * (4) If multiple constructors with the same signatures are defined within a class,
 *     only throw an error if they call the same super constructor.
 * (5) For non-abstract CJ classes, check that all non-conditional constructors in the
 *     hierarchy reference an existing superclass constructor.
 */
aspect CCNameCheck {

	// Aspect goal (1)
	refine NameCheck public void ParameterDeclaration.nameCheck() {
		if (!(getParent() instanceof FormalConstructorParameterDeclaration))
			NameCheck.ParameterDeclaration.nameCheck();
	}
	
	inh BodyDecl ConstructorParameterDeclaration.enclosingBodyDecl();
	
	inh VariableScope ConstructorParameterDeclaration.outerScope();
	
	// Aspect goal (2)
	public void ConstructorParameterDeclaration.nameCheck() {
		/*
		 * This is very similar to ParameterDeclaration.nameCheck() as defined by NameCheck.
		 * Additionally, ConstructorParameterDeclarations are considered.
		 */
		SimpleSet decls = outerScope().lookupVariable(name());
		for (Iterator iter = decls.iterator(); iter.hasNext();) {
			Variable var = (Variable) iter.next();
			if (var instanceof VariableDeclaration) {
				VariableDeclaration decl = (VariableDeclaration) var;
				if (decl.enclosingBodyDecl() == enclosingBodyDecl())
					error("duplicate declaration of local variable " + name());
			} else if (var instanceof ParameterDeclaration) {
				ParameterDeclaration decl = (ParameterDeclaration) var;
				if (decl.enclosingBodyDecl() == enclosingBodyDecl())
					error("duplicate declaration of local variable " + name());
			} else if (var instanceof ConstructorParameterDeclaration) {
				ConstructorParameterDeclaration decl = (ConstructorParameterDeclaration) var;
				if (decl.enclosingBodyDecl() == enclosingBodyDecl())
					error("duplicate declaration of local variable " + name());
			}
		}

		// 8.4.1
		if (!lookupVariable(name()).contains(this)) {
			error("duplicate declaration of parameter " + name());
		}
	}

	// Aspect goal (3)	 
	refine NameCheck public void ConstructorAccess.nameCheck() {
		refined();
		if (decls().size() == 1 && decl() instanceof CondConstructorDecl)
			error("A normal constructor may not call a conditional constructor because it is not guaranteed to be available at runtime.");
	}
	
	// Aspect goal (4)
	public void CondConstructorDecl.nameCheck() {
		// 8.8
		if (!hostType().name().equals(name()))
			error("constructor "
					+ name()
					+ " does not have the same name as the simple name of the host class "
					+ hostType().name());

		// 8.8.2
		ConstructorDecl thatConstructor = hostType().lookupConstructor(this);
		if (thatConstructor != this
				&& (getConstructorAccess() == null && thatConstructor.getConstructorAccess() == null ||
				    getConstructorAccess() != null && getConstructorAccess()
						.sameSignature(thatConstructor.getConstructorAccess())))
			error("constructor with signature " + signature()
					+ " is multiply declared in type " + hostType().typeName());

		if (circularThisInvocation(this))
			error("The constructor " + signature()
					+ " may not directly or indirectly invoke itself");
	}
	
	// Aspect goal (5)
	refine MCErrorCheck public void CjClassDecl.nameCheck() {
		refined();
		if (isAbstract())
			return;
		final java.util.List<TypeDecl> parents = getSortedParents();
		for (int i = 0; i <= parents.size(); i++)
			checkConstructorsForClassWithParent(
					i == 0 ? this : parents.get(i - 1),
					i < parents.size() ? parents.get(i) : typeCjObject());
	}
	
	private void CjClassDecl.checkConstructorsForClassWithParent(
			final TypeDecl currentClass, final TypeDecl directParent) {
		for (ConstructorDecl constructor : (Collection<ConstructorDecl>) currentClass
				.constructors()) {
			final ConstructorAccessIfc constructorAccess = constructor
					.getConstructorAccess();
			if (!(constructorAccess instanceof SuperConstructorAccess))
				continue;
			final SuperConstructorAccess superConstructorAccess = (SuperConstructorAccess) constructorAccess;
			final SimpleSet decls = superConstructorAccess.chooseConstructor(
					directParent.constructors(),
					superConstructorAccess.getArgList());
			if (decls.isEmpty())
				error("no constructor in " + directParent.name() + " matches "
						+ superConstructorAccess
						+ " for invocation from class " + currentClass.name());
			if (decls.size() > 1 && superConstructorAccess.validArgs()) {
				error("several most specific constructors in "
						+ directParent.name() + " for "
						+ superConstructorAccess
						+ " for invocation from class " + currentClass.name());
				for (final Iterator iter = decls.iterator(); iter.hasNext();) {
					error("         "
							+ ((ConstructorDecl) iter.next()).signature());
				}
			}
		}
	}
	
}