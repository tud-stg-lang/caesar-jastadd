aspect MCConstructors {
	
	public static final String Program.CJ_INIT_NAME = "$cj$init";
	
	/**********************************************************************************
     * 
     *  Transforming Instantiation Expressions 
     *
     */
	
	public boolean ClassInstanceExpr.isGeneratedCIE = false;
	syn boolean ClassInstanceExpr.isCjInstanceExpr() = false;
	
	public boolean ClassInstanceExpr.needsInitMethod() {
		return !isGeneratedCIE && !hasTypeDecl() && getAccess().type().isCjClassDecl();
	}
	
	public Dot ClassInstanceExpr.transformToInitMethod() { 
		ClassInstanceExpr prefix = new ClassInstanceExpr(getAccess(), new List(), new Opt());
		prefix.isGeneratedCIE = true;
		InitMethodAccess initCall = new InitMethodAccess(getArgList(), Program.CJ_INIT_NAME); 
		return new Dot(prefix, initCall);	
	}
			
	// rewrite all constructor calls to cclasses with parameters 
	// to constructor calls without parameters and call of an init method	
	rewrite ClassInstanceExpr {
		when ( !isGeneratedCIE && !hasTypeDecl() && getAccess().type().isCjClassDecl() )
		to Expr {
			return transformToInitMethod(); 		
		}
	}
	
	refine ResolveAmbiguousNames eq Access.prevExpr() {
		if (isRightChildOfDot()) {
			return parentDot().leftSide();
		}
		else {
			Access acc = this;
			while (acc.isLeftChildOfDot()) {
				acc = acc.parentDot();
			}
			if (acc.isRightChildOfDot()) {
				return acc.parentDot().leftSide();
			}			
		}		
		throw new Error(this + " does not have a previous expression");
	}

	refine ResolveAmbiguousNames eq Access.hasPrevExpr() {
		if (isRightChildOfDot()) {
			return true;
		}
		else {
			Access acc = this;
			while (acc.isLeftChildOfDot()) {
				acc = acc.parentDot();
			}
			if (acc.isRightChildOfDot()) {
				return true;
			}			
		}		
		return false;
	}
	
	eq InitMethodAccess.type() = prevExpr().type();
		
	/**********************************************************************************
     * 
     *  Transforming Constructor Declarations   
     *
     */
	
	syn boolean BodyDecl.isInitMethod() = false;
	eq CjInitMethodDecl.isInitMethod() = true;
	
	public boolean ConstructorDecl.isGeneratedConstr = false;
		
	// rewrite all constructors in cclasses to corresponding init methods 
    // then a new default constructor will be created by constructors() attribute
	// wait unit another rewrite creates a super constructor invocation
	rewrite ConstructorDecl {
	    when ( !isGeneratedConstr && hasConstructorInvocation() && hostType().isCjClassDecl() )
	    to MethodDecl {
	    	List stmts = new List();	        
	        // create super call
	        Expr cie = ((ExprStmt)getConstructorInvocation()).getExpr();
			if (cie instanceof ConstructorAccess) {
				ConstructorAccess ca = (ConstructorAccess)cie;
				Access initCall = new MethodAccess(Program.CJ_INIT_NAME, ca.getArgList());
				Expr prefix = (ca instanceof SuperConstructorAccess) ?
						new SuperAccess("super") : new ThisAccess("this");
				stmts.add(new ExprStmt(new Dot(prefix, initCall)));
			}		
			// copy all statements from constructor body
			for (int i = 0; i < getBlock().getNumStmt(); i++) {
				stmts.add(getBlock().getStmt(i));
			}
			// return this at the end of the method
	        stmts.add(new ReturnStmt(new ThisAccess("this")));
	        
	        MethodDecl decl = new CjInitMethodDecl(getModifiers(),
	                       			new DirectTypeAccess(typeCjObject()),
	                       			Program.CJ_INIT_NAME,
	                       			getParameterList(),
	                       			new List(),
	                       			getExceptionList(),
	                       			new Opt(new Block(stmts)));
	        return decl;
	    }
	}
	
	syn lazy ConstructorDecl CjClassDecl.getRealConstructor() {
		Modifiers m = new Modifiers();
        m.addModifier(new Modifier("public"));
		// generate true constructor
        ConstructorDecl decl = new CjConstructorDecl(
						              m,
						              name(),
						              new List(),
						              new List(),
						              new Opt(),
						              new Block());
        decl.isGeneratedConstr = true;
        return decl;
	}
	
	// inherited attributes for the real constructor
	eq CjClassDecl.getRealConstructor().hostType() = hostType();
	    
    // add implicit constructor
    eq CjClassDecl.constructors() {
      Collection c = new ArrayList();
      c.add(getRealConstructor());
      return c;
    }
    
    /**********************************************************************************
     * 
     *  Change code generation of constructors:
     *  see code between "begin change" and "end change"
     *
     */
    
    eq CjConstructorDecl.descName() {
    	StringBuffer b = new StringBuffer();
    	b.append("(");
    	// this$0
    	TypeDecl typeDecl = hostType();
    	if(typeDecl.needsEnclosing())
    		// begin change
    		b.append(typeDecl.typeObject().typeDescriptor());
    	// end change
    	if(typeDecl.needsSuperEnclosing()) {
    		TypeDecl superClass = ((ClassDecl)typeDecl).superclass();
    		b.append(superClass.enclosingType().typeDescriptor());
    	}
    	// args
    	for (int i=0; i<getNumParameter(); i++)
    		b.append(getParameter(i).type().typeDescriptor());
    	// this$val
    	for(Iterator iter = typeDecl.enclosingVariables().iterator(); iter.hasNext(); )
    		b.append(((Variable)iter.next()).type().typeDescriptor());
    	b.append(")V");
    	return b.toString();
    }

    public void CjConstructorDecl.createBCode(CodeGeneration gen) {
    	boolean needsInit = true;

    	if(hasConstructorInvocation()) {
    		getConstructorInvocation().createBCode(gen);
    		Stmt stmt = getConstructorInvocation();
    		if(stmt instanceof ExprStmt) {
    			ExprStmt exprStmt = (ExprStmt)stmt;
    			Expr expr = exprStmt.getExpr();
    			if(!expr.isSuperConstructorAccess())
    				needsInit = false;

    		}
    	}

    	int localIndex = 1;
    	if(hostType().needsEnclosing()) {
    		TypeDecl type = hostType().enclosingType();
    		gen.emitLoadReference(0);
    		gen.emitLoadReference(localIndex);
    		// begin change
    		hostType().typeObject().emitCastTo(gen, hostType().enclosingType());
    		// end change
    		String classname = hostType().constantPoolName();
    		String desc = type.typeDescriptor();
    		String name = "this$0";
    		int index = gen.constantPool().addFieldref(classname, name, desc);
    		gen.emit(Bytecode.PUTFIELD, -2).add2(index);
    		localIndex++;
    	}
    	if(needsSuperEnclosing()) {
    		localIndex++;
    	}
    	for(int i = 0; i < getNumParameter(); i++)
    		localIndex += getParameter(i).type().variableSize();
    	for(Iterator iter = hostType().enclosingVariables().iterator(); iter.hasNext(); ) {
    		Variable v = (Variable)iter.next();
    		gen.emitLoadReference(0);
    		v.type().emitLoadLocal(gen, localIndex);
    		String classname = hostType().constantPoolName();
    		String desc = v.type().typeDescriptor();
    		String name = "val$" + v.name();
    		int index = gen.constantPool().addFieldref(classname, name, desc);
    		gen.emit(Bytecode.PUTFIELD, -1 - v.type().variableSize()).add2(index);
    		localIndex += v.type().variableSize();
    	}

    	if(needsInit) {
    		TypeDecl typeDecl = hostType();
    		for(int i = 0; i < typeDecl.getNumBodyDecl(); i++) {
    			BodyDecl b = typeDecl.getBodyDecl(i);
    			if(b instanceof FieldDeclaration && b.isBytecodeField()) {
    				FieldDeclaration f = (FieldDeclaration)b;
    				if(!f.isStatic() && f.hasInit()) {
    					gen.emit(Bytecode.ALOAD_0);
    					f.getInit().createBCode(gen);
    					f.getInit().type().emitAssignConvTo(gen, f.type()); // AssignConversion
    					f.emitStoreField(gen, hostType());
    				}
    			}
    			else if(b instanceof InstanceInitializer) {
    				b.createBCode(gen);
    			}
    		}
    	}
    	gen.maxLocals = Math.max(gen.maxLocals, getBlock().localNum());
    	getBlock().createBCode(gen);
    }  

    /**********************************************************************************
     * 
     *  Final field assignment checks    
     *
     */
    
    // switch off checking of final field assignment in generated constructors 
	refine DefiniteAssignment eq ConstructorDecl.isDAafter(Variable v) = true;
	
	eq CjInitMethodDecl.fieldInitializationAllowed() = isInitMethod();
	
	eq CjInitMethodDecl.isDAafter(Variable v) = getBlock().isDAafter(v) && getBlock().checkReturnDA(v);
	eq CjInitMethodDecl.getBlock().isDAbefore(Variable v) = isDAbefore(v);
	
	eq CjInitMethodDecl.isDUafter(Variable v) = getBlock().isDUafter(v) && getBlock().checkReturnDU(v);
	eq CjInitMethodDecl.getBlock().isDUbefore(Variable v) = isDUbefore(v);
	
	eq CjClassDecl.getBodyDecl().isDUbefore(Variable v) {
		BodyDecl b = getBodyDecl(childIndex);
	    if ((b instanceof MethodDecl && !b.isInitMethod()) || b instanceof MemberTypeDecl) {
	      return false;
	    }
	    if(v.isClassVariable() || v.isInstanceVariable()) {
	      int index = childIndex - 1;
	      if(b instanceof ConstructorDecl)
	        index = getNumBodyDecl() - 1;
	        
	      for(int i = index; i >= 0; i--) {
	        b = getBodyDecl(i);
	        if(b instanceof FieldDeclaration) {
	          FieldDeclaration f = (FieldDeclaration)b;
	          //System.err.println("  working on field " + f.name() + " which is child " + i);
	          if(f == v)
	            return !f.hasInit();
	          if((v.isClassVariable() && f.isStatic()) || (v.isInstanceVariable() && !f.isStatic()))
	            return f.isDUafter(v);
	          //System.err.println("  field " + f.name() + " can not affect " + v.name());
	        }
	        else if(b instanceof StaticInitializer && v.isClassVariable()) {
	          StaticInitializer si = (StaticInitializer)b;
	          //System.err.println("  working on static initializer which is child " + i);
	          return si.isDUafter(v);
	        }
	        else if(b instanceof InstanceInitializer && v.isInstanceVariable()) {
	          InstanceInitializer ii = (InstanceInitializer)b;
	          //System.err.println("  working on instance initializer which is child " + i);
	          return ii.isDUafter(v);
	        }
	      }
	    }
	    //System.err.println("Reached TypeDecl when searching for DU for variable");
	    return isDUbefore(v);
	}
	
}