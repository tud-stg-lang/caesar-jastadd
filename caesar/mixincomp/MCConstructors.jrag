aspect MCConstructors {
	
	/**********************************************************************************
     * 
     *  Transforming Instantiation Expressions 
     *
     */
     
	/*
	 * Go up in tree structure recursively in order to find the previous expression.
	 */
	refine ResolveAmbiguousNames eq Access.prevExpr() {
		if (isRightChildOfDot()) {
			return parentDot().leftSide();
		}
		else {
			Access acc = this;
			while (acc.isLeftChildOfDot()) {
				acc = acc.parentDot();
			}
			if (acc.isRightChildOfDot()) {
				return acc.parentDot().leftSide();
			}			
		}		
		throw new Error(this + " does not have a previous expression");
	}

	refine ResolveAmbiguousNames eq Access.hasPrevExpr() {
		if (isRightChildOfDot()) {
			return true;
		}
		else {
			Access acc = this;
			while (acc.isLeftChildOfDot()) {
				acc = acc.parentDot();
			}
			if (acc.isRightChildOfDot()) {
				return true;
			}			
		}		
		return false;
	}
	
	// Equivalent ClassInstanceExpr.createBCode 
    // but avoid passing outer object
	public void CjClassInstanceExpr.createBCode(CodeGeneration gen) {
    	type().emitNew(gen);
    	type().emitDup(gen);
    
    	for (int i = 0; i < getNumArg(); ++i) {
      		getArg(i).createBCode(gen);
      		getArg(i).type().emitCastTo(gen, decl().getParameter(i).type()); // MethodInvocationConversion
    	}

    	if(decl().isPrivate() && type() != hostType()) {
     		gen.emit(Bytecode.ACONST_NULL);
      		decl().createAccessor().emitInvokeConstructor(gen);
    	}
    	else {
      		decl().emitInvokeConstructor(gen);
    	}
  	}	
		
	/**********************************************************************************
     * 
     *  Transforming Constructor Declarations   
     *
     */
	
	eq CjClassDecl.needsEnclosing() = false;
		
}