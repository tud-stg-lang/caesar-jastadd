// Byte code generation for mixin composition:
// - Creates class attributes with the information about inherited mixins.
//   The attributes are used by a special class loader, which creates
//   necessary mixin copies on demands
// - Calls interface separation and creation of accessor methods before byte code 
//   generation

aspect MCByteCode {
	
	// MixerConfigAttribute contains mixin list which is user by classloader to create mixin copies
	class MixerConfigAttribute extends Attribute {
		public MixerConfigAttribute(CjClassDecl decl) {
			super(decl.constantPool(), "de.tud.caesarj.mixerconfig");
			ConstantPool c = decl.constantPool();
			Collection v = decl.mixinList();
			u2(v.size());
			for (Iterator iter = v.iterator(); iter.hasNext();) {
				CjClassDecl cjclass = (CjClassDecl) iter.next(); 
				u2(c.addClass(cjclass.constantPoolName()));
			}
		}
	}
	
	// special attributes for cclasses
	eq CjClassDecl.attributes() {
  		// YANG Baustelle (changed order of attributes)
		Collection c = new Vector();
		if (getDirectParents().size() > 1)
			c.add(new MixerConfigAttribute(this));
		
		// The mechanism for parsing a CjVirtualClassDecl as such (and not as a ClassDecl) relies on
		// the IsCjClassAttribute being set before the generic attributes from TypeDecl.attributes().
		c.add(new IsCjClassAttribute(constantPool()));
		c.add(new CjSuperclassesAttribute((CjClassDecl)this));
		c.addAll(super.attributes());
		
		return c;
	}

   public void CjClassDecl.mixinCompTransform() {
	   // generate interface
	   InterfaceDecl ccifc = getCjInterface();
	   setImplementsList(new List().add(new DirectTypeAccess(ccifc)));
	   ccifc.addAccessorsToBody(this);
	   addAccessorsToBody();
	   addBodyDecl(getRealConstructor());
	}
	
	// changed cclass binary file extension to .cjclass
	// if cclass has more than one superclass - write $$super as superclass
	public void CjClassDecl.generateClassfile() {
		// perform necessary tranformations for mixin composition
		mixinCompTransform();
		// generate byte code of the generated interface
		getCjInterface().generateClassfile();
		// changed caesar binary file extension
    	super.generateClassfile(".cjclass", true);
	    // for testing only - to open with DJ Decompiler an additional class file must be created
//	    super.generateClassfile("_.class");
	}
	
	// this method could not be reused and must be split because of hardcoded file extension
	refine GenerateClassfile public void ClassDecl.generateClassfile() {
		generateClassfile(".class");
	}
	
  	public void ClassDecl.generateClassfile(String fileExtension) {
  		generateClassfile(fileExtension, false);
	}
  
	public void ClassDecl.generateClassfile(String fileExtension, boolean isCjClass) {
		// super call forces nested types to be generated first
	    super.generateClassfile();
	    String fileName = destinationPath() + File.separator + constantPoolName() + fileExtension;
	    if(Program.verbose()) System.out.println("Writing class file to " + fileName);
	    try {
	      ConstantPool cp = constantPool();

	      // force building of constant pool
	      cp.addClass(constantPoolName());
	      if(hasSuperclass()) {
	        cp.addClass(superclass().constantPoolName());
	      }
	      for(Iterator iter = interfacesIterator(); iter.hasNext(); )
	        cp.addClass(((TypeDecl)iter.next()).constantPoolName());
	      for(Iterator iter = bcFields().iterator(); iter.hasNext(); ) {
	        FieldDeclaration field = (FieldDeclaration) iter.next();
	        cp.addUtf8(field.name());
	        cp.addUtf8(field.type().typeDescriptor());
	        field.attributes();
	        if(field.needsAccessor()) {
	          cp.addUtf8("access$" + field.accessorIndex());
	          cp.addUtf8(field.accessorDescName());
	          field.accessorAttributes();
	        }
	        if(field.needsAccessorWrite()) {
	          cp.addUtf8("access$" + field.accessorWriteIndex());
	          cp.addUtf8(field.accessorWriteDescName());
	          field.accessorWriteAttributes();
	        }
	      }
	      if(isInnerType() && !isCjClassDecl()) {
	        TypeDecl type = enclosingType();
	        cp.addUtf8("this$0");
	        cp.addUtf8(type.typeDescriptor());
	        cp.addUtf8("Synthetic");
	      }
	      for(Iterator iter = enclosingVariables().iterator(); iter.hasNext(); ) {
	        Variable v = (Variable)iter.next();
	        cp.addUtf8("val$" + v.name());
	        cp.addUtf8(v.type().typeDescriptor());
	        cp.addUtf8("Synthetic");
	      }

	      for(Iterator iter = bcMethods().iterator(); iter.hasNext(); ) {
	        BodyDecl decl = (BodyDecl)iter.next();
	        decl.touchMethod(cp);
	      }
	      if(hasClinit()) {
	        cp.addUtf8("<clinit>");
	        cp.addUtf8("()V");
	        clinit_attributes();
	      }
	      attributes();


	      // Actual ClassFile generation
	      File dest = new File(fileName);
	      File parentFile = dest.getParentFile();
	      if(parentFile != null)
	        parentFile.mkdirs();
	      FileOutputStream f = new FileOutputStream(fileName);
	      DataOutputStream out = new DataOutputStream(new BufferedOutputStream(f));
	      out.writeInt(0xCAFEBABE);
	      out.writeChar(0);
	      out.writeChar(48);
	      cp.emit(out);
	      int flags = flags();
	      if(isNestedType())
	        flags = mangledFlags(flags);
	      flags |= Modifiers.ACC_SUPER;
	      out.writeChar(flags);
	      out.writeChar(cp.addClass(constantPoolName()));
	      out.writeChar(hasSuperclass() ? cp.addClass(superclass().constantPoolName()) : 0);
	      out.writeChar(getNumImplements());
	      for(Iterator iter = interfacesIterator(); iter.hasNext(); )
	        out.writeChar(cp.addClass(((TypeDecl)iter.next()).constantPoolName()));
	      Collection fields = bcFields();
	      out.writeChar(fields.size() + ((isInnerType() && !isCjClassDecl()) ? 1 : 0) + enclosingVariables().size());
	      for(Iterator iter = fields.iterator(); iter.hasNext(); ) {
	        FieldDeclaration field = (FieldDeclaration) iter.next();
	        out.writeChar(field.flags());
	        out.writeChar(cp.addUtf8(field.name()));
	        out.writeChar(cp.addUtf8(field.type().typeDescriptor()));
	        out.writeChar(field.attributes().size());
	        for(Iterator itera = field.attributes().iterator(); itera.hasNext();)
	          ((Attribute)itera.next()).emit(out);
	      }
	      if(isInnerType() && !isCjClassDecl()) {
	        TypeDecl type = enclosingType();
	        out.writeChar(0 /* Modifiers.ACC_PRIVATE */);
	        out.writeChar(cp.addUtf8("this$0"));
	        out.writeChar(cp.addUtf8(type.typeDescriptor()));
	        out.writeChar(1);
	        new SyntheticAttribute(cp).emit(out);

	      }
	      for(Iterator iter = enclosingVariables().iterator(); iter.hasNext(); ) {
	        Variable v = (Variable)iter.next();
	        out.writeChar(Modifiers.ACC_PRIVATE);
	        out.writeChar(cp.addUtf8("val$" + v.name()));
	        out.writeChar(cp.addUtf8(v.type().typeDescriptor()));
	        out.writeChar(1);
	        new SyntheticAttribute(cp).emit(out);
	      }

	      Collection methods = bcMethods();
	      out.writeChar(methods.size() + numAccessorMethods(methods) + (hasClinit() ? 1 : 0) + numAccessorFields(fields));
	      for(Iterator iter = methods.iterator(); iter.hasNext(); ) {
	        BodyDecl b = (BodyDecl)iter.next();
	        b.generateMethod(out, cp);
	      }
	      for(Iterator iter = fields.iterator(); iter.hasNext(); ) {
	        FieldDeclaration field = (FieldDeclaration) iter.next();
	        if(field.needsAccessor())
	          field.emitAccessor(cp, out);
	        if(field.needsAccessorWrite())
	          field.emitAccessorWrite(cp, out);
	      }
	      if(hasClinit()) {
	        out.writeChar(Modifiers.ACC_STATIC);
	        out.writeChar(cp.addUtf8("<clinit>"));
	        out.writeChar(cp.addUtf8("()V"));
	        out.writeChar(clinit_attributes().size());
	        for(Iterator itera = clinit_attributes().iterator(); itera.hasNext();)
	          ((Attribute)itera.next()).emit(out);
	      }
	      out.writeChar(attributes().size());
	      for(Iterator itera = attributes().iterator(); itera.hasNext();)
	        ((Attribute)itera.next()).emit(out);

	      out.close();
	    } catch (IOException e) {
	      e.printStackTrace();
	    }
	}

	refine TypeAnalysis eq TypeDecl.identityConversionTo(TypeDecl type) {
		if (TypeAnalysis.TypeDecl.identityConversionTo(type)) {
    		return true;
    	}
    	if (type.isCjClassDecl()) {
    		InterfaceDecl temp = type.getCjClassDecl().getCjInterface();
    		return temp.typeName().equals(this.typeName()); 
    	}
    	return false;	
	}
	
	/*
	refine ClassPath boolean ZipFilePart.selectCompilationUnit(String canonicalName) throws IOException {
		if (ClassPath.ZipFilePart.selectCompilationUnit(canonicalName))
			return true;
		
		// TODO refactor the whole fileSuffix() thing to accomodate CaesarJ binaries
		
    	String name = canonicalName.replace('.', '/'); // ZipFiles do always use '/' as separator
    	if (set.contains(name + ".cjclass")) {
    		nameWithExt = name + ".cjclass";
    		ZipEntry zipEntry = file.getEntry(nameWithExt);
    		if(zipEntry != null && !zipEntry.isDirectory()) {
    			is = file.getInputStream(zipEntry);
    			age = zipEntry.getTime();
    			pathName = file.getName();
    			relativeName = nameWithExt + ".cjclass";
    			fullName = canonicalName;
    			return true;    	  
    		}
    	}
    	return false;
    }
	*/
	
	
}
