// Adds checks that define semantics for private inheritance

aspect ErrorCheck {

    /******
  	 * Only top level types can have used classes
	 ******/
  	public void CjPrivInhClassDecl.nameCheck() {
  		super.nameCheck();
  		
  		if(!isTopLevelType() && getNumUsedClasses() != 0){ 
  			String usedClasses = ": ";
      		for(int i = 0; i < getNumUsedClasses(); i++){
      			usedClasses += ((TypeDecl)getUsedClasses(i).type()).name();
      			
      			if(i < getNumUsedClasses() - 1){ usedClasses += ", "; }
      		}
      		
  			error(name() + " is a (nested) virtual class and uses" + usedClasses +   
  				".  Only top-level families or normal classes can have used classes.");
  		}
  	}

	/*****
 	 * Abstract members and reqs cannot be inherited via uses
 	 *****/
	public void CjPrivInhClassDecl.checkModifiers() {
		super.checkModifiers();
		
		// Check for inherited abstract methods if class is abstract:
		
		//1.)  determine directly used classes
				// - for virtual classes use Enclosing Top Level i.e. further bounds 
				//   whose ETL is directly used by current ETL are the used classes 
		
		//2.)  determine unimplemented methods including used classes, this is the normal
			   // call to unimplemented()
		
		//3.)  determine unimplemented methods excluding used classes
		
		//4.)  determine unimplemented methods of all used classes
		
		//5.)  for all methods m in (4):
				//	not implemented -> (2) contains m
				//	not redeclared -> (3) doesn't contain m
					
				//		-> error!
						
		// Check for inh requirements is class is incomplete:
		
		//1.) same as above
		
		//2.) determine all unfulfilled required classes
		
		//3.) determine unfulfilled required classes excluding used classes
		
		//4.) determine unfulfilled required classes of all used classes
		
		//5.)  for all reqs r in (4):
				//	not fulfilled ->  (2) contains r
				//	not redeclared -> (3) doesn't contain r
	
				//		-> error!
		
	}

	/*****
 	 * Prevent access from indirect users
 	 *****/
 	 
	// Don't really know what check to refine / extend
	
	// MethodAccess.nameCheck() and VarAccess.nameCheck() TypeAccess.accessControl()?
	
	// Do I need to understand the whole lookUp procedure?
	
	// Where do I have enough information to:
	
    	// get all used classes (direct and indirect) 
    		// -> need enclosing class of access
    	// if declaring class is part of indirect used classes - trouble 
    		// -> need class where method/variable originates from
    
    

  	 
	/*****
  	 * Refine completeness check to disallow indirect users from fulfilling contract
  	 *****/
  	 
	// If class is complete refine completeness check to take usage into consideration
  	
  	// This seems really hard..  don't have an idea that makes much sense yet
  	
  	// The aim is to go through all unimplemented methods and check -- before replacing abstract versions of 
  	// a method by a concrete version -- that the concrete version is NOT from an indirect user that is not used 
  	// directly by any superclass that provides the contract to which the method belongs...
  	
  	/*****
  	 * Prevent subtyping to used classes
  	 *****/
  	 
  	// Still have to check what can be extended / has to be changed.. what check is carried out when subtyping?
  	 
}