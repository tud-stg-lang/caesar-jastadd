aspect VCErrorCheck {

	// this does not work - not possible to refine what is already refined
//	refine CjErrorCheck public void ClassDecl.nameCheck() {
//		 if (isInnerClass() && (!enclosingType().isCjClassDecl()))
//			 error("a class may only be within class and not within cclass " + enclosingType().typeName());
//		 CjErrorCheck.ClassDecl.nameCheck();
//	}
	// this causes error "multiple refinement of ..."
//	refine TypeHierarchyCheck public void ClassDecl.nameCheck() {
//	 if (isInnerClass() && (!enclosingType().isCjClassDecl()))
//		 error("a class may only be within class and not within cclass " + enclosingType().typeName());
//	 TypeHierarchyCheck.ClassDecl.nameCheck();
//}

	public void CjVirtualClassDecl.nameCheck() {
		super.nameCheck();
		for (int i=0; i<getNumBodyDecl(); i++)
			if (getBodyDecl(i) instanceof MemberTypeDecl) {
				MemberTypeDecl mcd = (MemberTypeDecl)getBodyDecl(i);
				TypeDecl t = mcd.getTypeDecl();
				if (t.isInterfaceDecl())
					error("a cclass "+name()+" may not have inner interface " + t.typeName());
				else if (!t.isCjClassDecl() && !t.isCjSuperType())
					error("a class "+t.name()+" may not be within cclass " + typeName());
			}
		if (isInnerClass() && (!enclosingType().isCjClassDecl()))
			 error("a virtual class "+ name() +" may not be within java class" + enclosingType().typeName());
		for(Iterator iter = getDeclaredParents().iterator(); iter.hasNext();) {
			TypeDecl explicitSuperType = (TypeDecl)iter.next();
			if (enclosedBy(explicitSuperType))
				error("a virtual class "+ name() +" may not inherit from enclosing cclass " + explicitSuperType.typeName());
			if (explicitSuperType.isNestedType())
				if (this==explicitSuperType.enclosingType())
					error("a cclass "+ name() +" may not inherit from own inner cclass " + explicitSuperType.typeName());
				else if(isTopLevelType() || enclosingType()!=explicitSuperType.enclosingType())
					error("a cclass "+ name()+" may not inherit from external inner cclass " + explicitSuperType.typeName());
		}
	}
	
	// allow static members in virtual classes
	refine Modifiers public void MemberDecl.checkModifiers() {
    	super.checkModifiers();
    	if (!hostType().isVirtualClassDecl() && isStatic() && hostType().isInnerClass() && !isConstant())
     		error("*** Inner classes may not declare static members, unless they are compile-time constant fields");
  	}

	// java allows protected and private constructors, caesar - only public 
	refine Modifiers public void ConstructorDecl.checkModifiers() {
	    super.checkModifiers();
	    if ((isProtected() || isPrivate()) && hostType().isVirtualClassDecl())
	    	error("constructor must be public in cclass " + hostType().typeName());
	}
	
	public void CjVirtualClassDecl.checkModifiers() {
		super.checkModifiers();
		
		// Unless none exist, ...
		if ((methodsSignatureMap() == null) || (methodsSignatureMap().keySet() == null)) {
			return;
		}
		// ... get all ancestor method signatures
		for(Iterator itSigs = methodsSignatureMap().keySet().iterator(); itSigs.hasNext(); ) {
			MethodSignature sig = (MethodSignature) itSigs.next();
			String lastMethodModifier = null;
			
			// Walk through all methods with this signature ... 
			for(Iterator itAM = ancestorMethods(sig).iterator(); itAM.hasNext(); ) {
				MethodDecl m = (MethodDecl)itAM.next();
				Modifiers modifiers = m.getModifiers();
				
				// ... and verify that the visibility modifiers match
				if ((lastMethodModifier != null) &&
						! (    (modifiers.isProtected() && lastMethodModifier.equalsIgnoreCase("protected"))
							|| (modifiers.isPublic() && lastMethodModifier.equalsIgnoreCase("public")) )) {
						error("overriding access modifier error in method " + m.getID());
				}

				if (modifiers.isPublic()) {
					lastMethodModifier = "public";
				} else if (modifiers.isProtected()) {
					lastMethodModifier = "protected";
				} else {
					error("overriding access modifier error in method " + m.getID());
				}
			}
		}
	}
	
	public void CjVirtualClassDecl.typeCheck() {
		super.typeCheck();
		this.getTopFurtherbound();
	}

}	
