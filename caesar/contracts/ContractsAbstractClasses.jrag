// Implements new semantic of being abstract, concrete, complete...

aspect ContractsAbstractClasses {

	// Removes required methods from list of unimplemented methods
	 eq CjContractClassDecl.unimplementedMethods() {

	 	Collection c = super.unimplementedMethods();
	 	
	 	// Go through all required classes and remove found required methods
	 	for (Iterator reqs = getAllRequiredClasses().iterator(); reqs.hasNext(); ) {
			ClassDecl cd = (ClassDecl)reqs.next();
		 	
		 	Collection r = new ArrayList();
			for(Iterator unimpMethods = c.iterator(); unimpMethods.hasNext(); ){
				MethodDecl m = (MethodDecl)unimpMethods.next();
			
				if(cd.memberMethods(m.name()).contains(m)){
					// Add required method to list of methods to be removed
					r.add(m);
				}
			}
			
			c.removeAll(r);
		}
		
		// Return altered list, required methods have now been removed
		return c;
	 }
	 
	// A class has requirements when its provider contract doesn't include all requirements 
	syn boolean CjContractClassDecl.hasRequirements() {
	
		// Get client contract
		Collection required = getAllRequiredClasses();
		
		/* for(Iterator iter = required.iterator(); iter.hasNext(); ){
			System.out.println("requires: " + ((ClassDecl)iter.next()).name());
		}
		*/
		
		// Get provider contract
		Collection provided = getAllExtendedClasses();
		
		/* for(Iterator iter = provided.iterator(); iter.hasNext(); ){
			System.out.println("provides: " + ((ClassDecl)iter.next()).name());
		}
		*/
		
		if(required.isEmpty())
			return false;
		else if(provided.isEmpty())
			return true; 
		
		return !provided.containsAll(required);
	}
	
	// A class is complete when it is concrete (not abstract) and has no requirements 
	syn boolean CjContractClassDecl.isComplete() = !isAbstract() && !hasRequirements();

}
