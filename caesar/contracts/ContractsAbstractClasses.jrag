// Implements new semantic of being abstract, concrete, complete...

aspect ContractsAbstractClasses {

	// Removes required methods from list of unimplemented methods
	// This allows concrete but incomplete classes, 
	// i.e. classes not declared abstract, but containing abstract methods via requirements
	 eq CjContractClassDecl.unimplementedMethods() {

		// Get complete list of abstract methods
	 	Collection c = super.unimplementedMethods();
	 	
	 	// Go through all required classes and remove found required methods
	 	for (Iterator reqs = getAllRequiredClasses().iterator(); reqs.hasNext(); ) {
			ClassDecl cd = (ClassDecl)reqs.next();
		 	
		 	Collection r = new ArrayList();
			for(Iterator unimpMethods = c.iterator(); unimpMethods.hasNext(); ){
				MethodDecl m = (MethodDecl)unimpMethods.next();
			
				if(cd.memberMethods(m.name()).contains(m)){
					// Add required method to list of methods to be removed
					r.add(m);
				}
			}
			
			c.removeAll(r);
		}
		
		// Return altered list, required methods have now been removed
		return c;
	 }
	 
	// A class has requirements when its provider contract doesn't include its client contract 
	// The provider contract consists of all extended classes
	// The client contract consists of all required classes
	syn boolean CjContractClassDecl.hasRequirements() {
	
		// Get client contract
		Collection required = getAllRequiredClasses();
		
		// Get provider contract
		Collection provided = getAllExtendedClasses();
		
		// Check if all requirements are met
		if(required.isEmpty())
			return false;
		else if(provided.isEmpty())
			return true; 
		
		return !provided.containsAll(required);
	}
	
	// A class is complete when it is concrete (not abstract) and has no requirements 
	syn boolean CjContractClassDecl.isComplete() = !isAbstract() && !hasRequirements();

}
