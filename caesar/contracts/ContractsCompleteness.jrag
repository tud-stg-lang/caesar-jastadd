// Implements new semantic of concrete, abstract and complete classes 
// Based on definition of completeness in doc/caesarj_spec.pdf/Contracts

aspect ContractsCompleteness {

	/******
	 * 1.) <extends> := getExplicitExtends() for classes
	 ******/
	syn lazy Collection CjContractClassDecl.getExplicitExtends() {
		Collection c = new HashSet();
		
		for(int i1 = 0; i1 < getNumSuperClasses(); i1++){
			c.add(getSuperClasses(i1).type());
		}
		
		return c;
	}
	
	/******
	 * 2.) <extends> := getExplicitExtends() for interfaces
	 ******/
	syn lazy Collection InterfaceDecl.getExplicitExtends() {
		Collection c = new ArrayList();
		
		for(int i = 0; i < getNumSuperInterfaceId(); i++){
			c.add(getSuperInterfaceId(i).type());
		}
		
		return c;
	}
	
	/******
	 * 3,4.) [extends] := getAllExtends() for classes
	 ******/
	syn lazy Collection CjContractClassDecl.getAllExtends() {
		// Avoid endless recursion
		if(isCircular())
			return Collections.EMPTY_LIST;
		
		Collection c = new HashSet();
	
		c.addAll(getExplicitExtends());
		
		// Call recursively (recursion anchor = no extends relationships)
		for(Iterator iter = getExplicitExtends().iterator(); iter.hasNext(); ){
			TypeDecl td = (TypeDecl)iter.next();
			
			if(td instanceof CjContractClassDecl){
				c.addAll(((CjContractClassDecl)td).getAllExtends());
			}
		}
		
		return c;
	}
	
	/******
	 * 3,4.) [extends] := getAllExtends() for interfaces
	 ******/
	syn lazy Collection InterfaceDecl.getAllExtends() {
		// Prevent endless recursion
	 	if(isCircular()) { return Collections.EMPTY_LIST; }
	
		Collection c = new ArrayList();
		
		c.addAll(getExplicitExtends());
		
		for(Iterator iter = getExplicitExtends().iterator(); iter.hasNext(); ){
			TypeDecl td = (TypeDecl)iter.next();
			
			// Ignore super classes like Object or wrong syntax (an error in the code)
			if(td instanceof InterfaceDecl)
				c.addAll(((InterfaceDecl)td).getAllExtends());
		}
		
		return c;
	}
	
	
	/******
	 * 5.) <implements> := getExplicitImplements()
	 ******/
	syn lazy Collection CjContractClassDecl.getExplicitImplements() {
		Collection imps = new ArrayList();
		
		// add all explicitly implemented
		for(int i = 0; i < getNumExplicitImplements(); i++){
			imps.add(getExplicitImplements(i).type());
		}
		
		return imps;
	}
	
	/******
	 * 6,7.) [provides] := getExplicitProvided()
	 ******/
	syn lazy Collection CjContractClassDecl.getExplicitProvided() {
		Collection provided = new HashSet();
	
		// An abstract class doesn't have to provide anything
		if(!isAbstract()){
			// For a concrete class, every contract via extends has to be fulfilled
			provided.addAll(getExplicitExtends());
			
			// Implemented interfaces are part of fulfilled contract
			provided.addAll(getExplicitImplements());
		}
		
		return provided;
	}
	
	/******
	 * 8,9.) [provides] := getProvided()
	 ******/
	syn lazy Collection CjContractClassDecl.getProvided() {
		// Virtual classes  (i.e. nested classes ) are handled differently
		if(isNestedType()){
			return getProvidedForVirtCls();
		}
	
		// Avoid endless recursion
		if(isCircular())
			return Collections.EMPTY_LIST;
			
		Collection c = new HashSet();
		
		// Add explicit provided
		c.addAll(getExplicitProvided());
		
		// Call recursively (recursion anchor = no extends relationships)
		for(Iterator iter = getExplicitExtends().iterator(); iter.hasNext(); ){
			TypeDecl td = (TypeDecl)iter.next();
			
			if(td instanceof CjContractClassDecl){
				CjContractClassDecl cd = (CjContractClassDecl)td;
				
				c.addAll(cd.getProvided());
				
				// Provided abstract classes do not provide anything but
				// nonetheless extend the contracts of their superclasses
				// This means these contracts are provided as well.
				if(cd.isAbstract()){
					c.addAll(cd.getSupertypesOf());
				}
			}
		}
		
		// Call recursively (recursion anchor = no implements relationships)
		if(!isAbstract()){
			for(Iterator iter = getExplicitImplements().iterator(); iter.hasNext(); ){
				TypeDecl td = (TypeDecl)iter.next();
			
				if(td instanceof InterfaceDecl){
					c.addAll(((InterfaceDecl)td).getAllExtends());
				}
			}
		}
		
		return c;
	}
	
	
	
	/******
	 * 10.) <requires> := getExplicitRequirements()
	 ******/

	syn lazy Collection CjContractClassDecl.getExplicitRequirements() {
		Collection c = new HashSet();
		
		// Add explicit (declared) requirements
		for (int i1 = 0; i1 < getNumRequiredClasses(); i1++) {
			c.add(getRequiredClasses(i1).type());
		}
		
		return c;
	}
	
	
	/******
	 * 11 - 16.) [subtypeof] := getSupertypesOf() for classes (i.e. A [subtypeof] B == A.getSupertypesOf().contains(B))
	 ******/
	syn lazy Collection CjContractClassDecl.getSupertypesOf() {
		// Avoid endless recursion
		if(isCircular())
			return Collections.EMPTY_LIST;
		
		Collection c = new HashSet();
		
		// Add explicit extends
		c.addAll(getExplicitExtends());
		
		// Add explicit requirements
		c.addAll(getExplicitRequirements());
		
		// Add explicit implements
		c.addAll(getExplicitImplements());
		
		// Call recursively
		for(Iterator iter = getExplicitExtends().iterator(); iter.hasNext(); ){
			TypeDecl td = (TypeDecl)iter.next();
			
			if(td instanceof CjContractClassDecl){
				c.addAll(((CjContractClassDecl)td).getSupertypesOf());
			}
		}			
		
		for(Iterator iter = getExplicitRequirements().iterator(); iter.hasNext(); ){
			TypeDecl td = (TypeDecl)iter.next();
			
			if(td instanceof CjContractClassDecl){
				c.addAll(((CjContractClassDecl)td).getSupertypesOf());
			}
		}			
		
		for(Iterator iter = getExplicitImplements().iterator(); iter.hasNext(); ){
			TypeDecl td = (TypeDecl)iter.next();
			
			if(td instanceof CjContractClassDecl){
				c.addAll(((CjContractClassDecl)td).getSupertypesOf());
			}
		}			
					
		return c;
	}

	/******
	 * 17 - 19.) [requires] := getRequirements()
	 ******/
	syn lazy Collection CjContractClassDecl.getRequirements() {
		// Virtual classes  (i.e. nested classes ) are handled differently
		if(isNestedType()){
			return getReqsForVirtCls();
		}
	
		// Avoid endless recursion
		if(isCircular())
			return Collections.EMPTY_LIST;
		
		Collection c = new HashSet();
		
		// Add explicit requirements
		c.addAll(getExplicitRequirements());
		
		// Add recursively all supertypes of direct requirements
		for(Iterator iter = getExplicitRequirements().iterator(); iter.hasNext(); ){
			TypeDecl td = (TypeDecl)iter.next();
			
			if(td instanceof CjContractClassDecl){
				c.addAll(((CjContractClassDecl)td).getSupertypesOf());
			} else if(td instanceof InterfaceDecl){
				// For interfaces, getSupertypesOf simplifies to getAllExtends
				c.addAll(((InterfaceDecl)td).getAllExtends());
			}
		}			
		
		// Add recursively only requirements of extended parents
		for(Iterator iter = getExplicitExtends().iterator(); iter.hasNext(); ){
			TypeDecl td = (TypeDecl)iter.next();
			
			if(td instanceof CjContractClassDecl){
				c.addAll(((CjContractClassDecl)td).getRequirements());
			}
		}			
		
		return c;
	}

	/******
	 * Auxiliary method for 17, 19: Generalizes reqs for virtual classes 
	 * TODO:  It would be way more simple and intuitive to check if a class is concrete or not by 
	 *		  first excluding all requirements then performing the check as normal.
	 *		  This is however not so simple as it sounds since the check (accumulating all methods
	 *		  and checking if all abstract methods are implemented) is already implemented and would
	 *		  have to be understood and appropriately changed to ignore requirements. 
	 ******/
	syn lazy Collection CjContractClassDecl.getReqsForVirtCls(){
		// Avoid endless recursion
		if(isCircular())
			return Collections.EMPTY_LIST;
		
		// Get all implicit parents
		Collection parents = getDirectFurtherbounds();
		
		// Return implicit parents whose Enclosing Top Level 
		// is required by ETL of current class
		Collection reqs = new ArrayList();
		for(Iterator itr = parents.iterator(); itr.hasNext(); ){
			CjContractClassDecl cd = (CjContractClassDecl)itr.next();
			if(getEnclosingTopLevel() instanceof CjContractClassDecl){
				CjContractClassDecl tl = ((CjContractClassDecl)getEnclosingTopLevel());
				
			   	if(tl.getRequirements().contains(cd.getEnclosingTopLevel())){
					reqs.add(cd);
				}
			}
		}
		
		// Call recursively for explicit parents
		for(Iterator itr = getExplicitParents().iterator(); itr.hasNext();){
			Object cd = itr.next();
			if(cd instanceof CjContractClassDecl)
				reqs.addAll(((CjContractClassDecl) cd).getReqsForVirtCls());
		}
		
		// Class is implicit and only present via requirements - therefore skip check
		if(isImplicit && reqs.containsAll(parents)){
			reqs.add(this);
		}
		
		return reqs;
	}
	
	/******
	 * Auxiliary method for 8,9: Generalizes getProvided for virtual classes 
	 ******/
	syn lazy Collection CjContractClassDecl.getProvidedForVirtCls(){
		// Get all implicit parents
		Collection parents = getDirectFurtherbounds();
		
		// Return implicit parents whose Enclosing Top Level 
		// is provided by ETL of current class
		Collection provided = new ArrayList();
		for(Iterator itr = parents.iterator(); itr.hasNext(); ){
			CjContractClassDecl cd = (CjContractClassDecl)itr.next();
			if(getEnclosingTopLevel() instanceof CjContractClassDecl){
				CjContractClassDecl tl = ((CjContractClassDecl)getEnclosingTopLevel());
				
			   	if(tl.getProvided().contains(cd.getEnclosingTopLevel())){
					provided.add(cd);
				}
			}
		}
		
		return provided;
	}
	
	/******
	 * 20.) complete := isComplete()
	 ******/
	syn boolean CjContractClassDecl.isComplete() 
						= !isAbstract() && getProvided().containsAll(getRequirements());
						
}