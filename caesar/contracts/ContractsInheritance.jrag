// Implements correct inheritance relationships with contracts

aspect ContractsInheritance {

	/****** 
	 * Overwrites attribute from CjClassDecl responsible for determining superclasses
	 * Adds required interfaces to list of implemented interfaces
	 * This allows for subtyping and method access via requirements
	 ******/									  
	eq CjContractClassDecl.getDeclaredParents() {
		Collection parents = new HashSet();
		
		// Add parents via direct extends
		parents.addAll(super.getDeclaredParents());
		
		// Add parents via direct requirements
		parents.addAll(getExplicitRequirements());
		
		// Remove requirements that are interfaces since
		// these are not to be regarded as superclasses
		parents.removeAll(getReqInterfaces());
		
		// Add required interfaces instead to list of implemented interfaces
  		Collection c = new ArrayList();
		for(int i = 0; i < getNumImplements(); i++){
     		c.add(getImplements(i));
     	}
	
     	for(int i = 0; i < getNumRequiredClasses(); i++){
     		TypeDecl td = (TypeDecl)(getRequiredClasses(i).type());
     	
     		// If requirement is an interface and it hasn't been added already	
     		if((td instanceof InterfaceDecl) && !c.contains(getRequiredClasses(i))){
     			addImplements(getRequiredClasses(i));	
     		}
     	}  
     	
	    return parents;
	}


	/******
	 * Override method in CjVirtualClassDecl to instantiate implicit virtual classes of right type
	 ******/
	public CjVirtualClassDecl CjContractClassDecl.createImplicitClass(Modifiers modifiers, String name) {
		return new CjContractClassDecl(modifiers, name, new List(), new List(), new List(), new List());
	}
	
	/******
	 * Determine requirements that are interfaces
	 ******/
	syn lazy Collection CjContractClassDecl.getReqInterfaces() {
		ArrayList reqs = new ArrayList();
	
		for(int i = 0; i < getNumRequiredClasses(); i++){
			TypeDecl td = (TypeDecl)(getRequiredClasses(i).type());
			
			// Requirements via interfaces 
			if(td instanceof InterfaceDecl){ reqs.add(td); }
		}
		
		return reqs;
	}
}