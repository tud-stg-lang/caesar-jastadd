// Removes required methods from list of unimplemented methods
// This allows concrete but incomplete classes, 
// i.e. classes not declared abstract, but containing abstract methods via requirements

aspect ContractsMethods {	 
	 /******
	  * Remove required methods from list of unimplemented methods
	  ******/
	 eq CjContractClassDecl.unimplementedMethods() {

		// Get complete list of abstract methods
	 	Collection c = super.unimplementedMethods();
	 	
	 	// Remove all required methods from list of unimplemented methods
	 	for(Iterator reqs = getRequirements().iterator(); reqs.hasNext(); ){
	 		TypeDecl td = (TypeDecl)reqs.next();
	 	
	 		if(getProvided().contains(td)){
	 			// If requirement is part of contract to be provided (redundant requirement)
	 			// do not remove methods from set of unimplemented methods
	 		}else if(td instanceof CjContractClassDecl || td instanceof InterfaceDecl){
				Collection r = new HashSet();
			
		 		for(Iterator unimpMethods = c.iterator(); unimpMethods.hasNext(); ){
					MethodDecl m = (MethodDecl)unimpMethods.next();
		
					// Remove methods of required class or interface
					if(td.memberMethods(m.name()).contains(m)){
						r.add(m);
					}	
	 			}
	 				
	 			c.removeAll(r);
	 		}
	 	}
	 	
	 	return c;
	 }
	 
	  /******
	  * Determine the enclosing top-level type
	  ******/
	 syn lazy TypeDecl CjContractClassDecl.getEnclosingTopLevel(){
	 	TypeDecl cd = this;
	 	
	 	while(!cd.isTopLevelType()){
	 		cd = cd.enclosingType();
	 	}
	 	
	 	return cd;
	 }
}