aspect GenericsCodegen {
    
   eq TypeVariable.typeDescriptor() = erasure().typeDescriptor();

   syn boolean TypeVariable.isNestedType() = false;


   public Access RawClassDecl.createQualifiedAccess() {
     System.out.println("Creating qualified access to RawClassDecl" + name());
     List list = new List();
     for(int i = 0; i < getNumTypeParameter(); i++)
       list.add(getTypeParameter(i).erasure().createQualifiedAccess());
     if(isTopLevelType())
       return new RawTypeAccess(packageName(), name(), list);
     else
       return enclosingType().createQualifiedAccess().qualifiesAccess(new RawTypeAccess(name(), list));
   }

   public RawTypeAccess.RawTypeAccess(String typeName, List list) {
    this("", typeName, list);
  }
  
  public ParameterizedTypeAccess.ParameterizedTypeAccess(String typeName, List list) {
    this("", typeName, list);
  }

  // accessibility for members in generic classes
  // the accessibility for parameterized and raw versions of a generic class
  // should be the same as for the generic class, in other words the erasure of the 
  // paramterized version.
  eq ParClassDecl.accessibleFrom(TypeDecl type) =
    erasure().accessibleFrom(type);
  eq ParClassDecl.topLevelType() = erasure().topLevelType();


}
