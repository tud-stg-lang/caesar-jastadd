ClassDecl class_declaration =
		modifiers.m CLASS IDENTIFIER.id type_parameters.p super_opt.s interfaces_opt.i class_body.b 
		{:  return new GenericClassDecl(m, id, s, i, b, p, new List(), new Opt());  :}
	|	            CLASS IDENTIFIER.id type_parameters.p super_opt.s interfaces_opt.i class_body.b 
		{:  return new GenericClassDecl(new Modifiers(new List()), id, s, i, b, p, new List(), new Opt());  :}
	;

Opt super_opt =
  {: return new Opt(); :}
  | super.s {: return s; :}
  ;

List interfaces_opt =
    {: return new List(); :}
  | interfaces.i {: return i; :}
  ;

List extends_interfaces_opt =
                       {: return new List(); :}
  | extends_interfaces {: return extends_interfaces; :}
  ;
  
InterfaceDecl interface_declaration =
		modifiers.m INTERFACE IDENTIFIER.id type_parameters.p extends_interfaces_opt.i interface_body.b 
		{:  return new GenericInterfaceDecl(m, id, i, b, p, new List(), new Opt());  :}
	|             INTERFACE IDENTIFIER.id type_parameters.p extends_interfaces_opt.i interface_body.b 
		{:  return new GenericInterfaceDecl(new Modifiers(new List()), id, i, b, p, new List(), new Opt());  :}
	;

Access class_or_interface_type =
		name.t LT type_argument_list_1.l {:  return new ParTypeAccess(t, l);  :}
  | class_or_interface_type.t DOT IDENTIFIER.id {: return t.qualifiesAccess(new ParseName(id)); :}
  | class_or_interface_type.t DOT IDENTIFIER.id LT type_argument_list_1.l 
    {: return new ParTypeAccess(t.qualifiesAccess(new ParseName(id)), l); :}
	;
Access array_type =
    	name.t LT type_argument_list_1.l DOT name.n dims.d 
    	{:  return new ArrayTypeAccess(new ParTypeAccess(t, l).qualifiesAccess(n), d.getNumChild());  :}
	|	name.t LT type_argument_list_1.l dims.d 
		{:  return new ArrayTypeAccess(new ParTypeAccess(t, l), d.getNumChild());  :}
	;

List type_arguments =
		LT type_argument_list_1.l {:  return l;  :}
	;
      
Access wildcard =
		QUESTION                             {: return new Wildcard(); :}
	|	QUESTION EXTENDS reference_type.t    {: return new WildcardExtends(t); :}
    |	QUESTION SUPER reference_type.t    {: return new WildcardSuper(t); :}
    ;
   
Access wildcard_1 =
		QUESTION GT                          {: return new Wildcard(); :}
	|	QUESTION EXTENDS reference_type_1.t  {: return new WildcardExtends(t); :}
	|	QUESTION SUPER reference_type_1.t    {: return new WildcardSuper(t); :}
	;
	
Access wildcard_2 =
		QUESTION RSHIFT                      {: return new Wildcard(); :}
	|	QUESTION EXTENDS reference_type_2.t  {: return new WildcardExtends(t); :}
	|	QUESTION SUPER reference_type_2.t    {: return new WildcardSuper(t); :}
	;
	
Access wildcard_3 =
		QUESTION URSHIFT                     {: return new Wildcard(); :}
	|	QUESTION EXTENDS reference_type_3.t  {: return new WildcardExtends(t); :}
	|	QUESTION SUPER reference_type_3.t    {: return new WildcardSuper(t); :}
	;

Opt subclass_body_opt =
    {: return new Opt(); :}
  | subclass_body {: return subclass_body; :}
  ;

Expr class_instance_creation_expression =
	 	NEW type_arguments.a class_or_interface_type.t LPAREN argument_list_opt.l RPAREN subclass_body_opt.b
		{:  return new ParClassInstanceExpr(t, l, b, a); :}
    /*
	|	primary.n DOT NEW IDENTIFIER.id type_arguments.a LPAREN argument_list_opt.l RPAREN subclass_body_opt.b
        {:  return new NestedClassInstanceExpr(n, new ParTypeAccess(new ParseName(id), a), l, b ); :}	
        */
	|	primary.n DOT NEW type_arguments.ca IDENTIFIER.id LPAREN argument_list_opt.l RPAREN class_body_opt.b
		{:  return n.qualifiesAccess(new ParClassInstanceExpr(new ParseName(id), l, b, ca)); :}
    /*
	|	primary.n DOT NEW type_arguments.ca IDENTIFIER.id type_arguments.ta LPAREN argument_list_opt.l RPAREN class_body_opt.b
		{:  return new ParNestedClassInstanceExpr(n, new ParTypeAccess(new ParseName(id), ta), l, b, ca); :}
	|	name.n DOT NEW IDENTIFIER.id type_arguments.a LPAREN argument_list_opt.l RPAREN subclass_body_opt.b
		{:  return new NestedClassInstanceExpr(n, new ParTypeAccess(new ParseName(id), a), l, b);  :}
	|	name.n DOT NEW type_arguments.ca IDENTIFIER.id LPAREN argument_list_opt.l RPAREN class_body_opt.b
		{:  return new ParNestedClassInstanceExpr(n, new ParseName(id), l, b, ca);  :}
	|	name.n DOT NEW type_arguments.ca IDENTIFIER.id type_arguments.ta LPAREN argument_list_opt.l RPAREN class_body_opt.b
		{:  return new ParNestedClassInstanceExpr(n, new ParTypeAccess(new ParseName(id), ta), l, b, ca);  :}
    */
	;

List type_argument_list =
		type_argument.a {:  return new List().add(a);  :}
	|	type_argument_list.l COMMA type_argument.a {:  return l.add(a);  :}
	;
	
List type_argument_list_1 =
		type_argument_1.a {:  return new List().add(a);  :}
	|	type_argument_list.l COMMA type_argument_1.a {:  return l.add(a);  :}
	;
	
List type_argument_list_2 =
		type_argument_2.a {:  return new List().add(a);  :}
	|	type_argument_list.l COMMA type_argument_2.a {:  return l.add(a);  :}
	;
	
List type_argument_list_3 =
		type_argument_3.a {:  return new List().add(a);  :}
	|	type_argument_list.l COMMA type_argument_3.a {:  return l.add(a);  :}
	;
	
Access type_argument =
		reference_type.t {:  return t;  :}
	|	wildcard.w {: return w; :}
	;
	
Access type_argument_1 =
		reference_type_1.t {:  return t;  :}
	|	wildcard_1.w {: return w; :}
	;
	
Access type_argument_2 =
		reference_type_2.t {:  return t;  :}
	|	wildcard_2.w {: return w; :}
	;
	
Access type_argument_3 =
		reference_type_3.t {:  return t;  :}
	|	wildcard_3.w {: return w; :}
	;
  
Access reference_type_1 =
		reference_type.t GT {:  return t;  :}
	|	name.t LT type_argument_list_2.l {:  return new ParTypeAccess(t, l);  :}
	;
	
Access reference_type_2 =
		reference_type.t RSHIFT {:  return t;  :}
	|	name.t LT type_argument_list_3.l {:  return new ParTypeAccess(t, l);  :}
	;
	
Access reference_type_3 =
		reference_type.t URSHIFT {:  return t;  :}
	;
Expr cast_expression =
		LPAREN name.n LT type_argument_list_1.a RPAREN unary_expression_not_plus_minus.e 
		{:  return new CastExpr(new ParTypeAccess(n, a), e);  :}
	|	LPAREN name.n LT type_argument_list_1.a dims.d RPAREN unary_expression_not_plus_minus.e 
		{:  return new CastExpr(new ArrayTypeAccess(new ParTypeAccess(n, a), d.getNumChild()), e);  :}
	|	LPAREN name.n LT type_argument_list_1.a DOT class_or_interface_type.t RPAREN unary_expression_not_plus_minus.e 
		{:  return new CastExpr(new ParTypeAccess(n, a).qualifiesAccess(t), e);  :}
	|	LPAREN name.n LT type_argument_list_1.a DOT class_or_interface_type.t dims.d RPAREN unary_expression_not_plus_minus.e 
		{:  return new CastExpr(new ArrayTypeAccess(new ParTypeAccess(n, a).qualifiesAccess(t), d.getNumChild()), e);  :}
  ;
List type_parameters =
		LT type_parameter_list_1.l {:  return l;  :}
	;
	
List type_parameter_list =
		type_parameter_list.l COMMA type_parameter.p {:  return l.add(p);  :}
	|	type_parameter.p {:  return new List().add(p);  :}
	;
	
List type_parameter_list_1 =
		type_parameter_1.p {:  return new List().add(p);  :}
	|	type_parameter_list.l COMMA type_parameter_1.p {:  return l.add(p);  :}
	;
	
TypeVariable type_parameter =
		IDENTIFIER.v              {:  return new TypeVariable(new Modifiers(), v, new List(), new List());  :}
	|	IDENTIFIER.v type_bound.l {:  return new TypeVariable(new Modifiers(), v, new List(), l); :}
	;
	
TypeVariable type_parameter_1 =
		IDENTIFIER.v GT             {:  return new TypeVariable(new Modifiers(), v, new List(), new List());  :}
  |	IDENTIFIER.v type_bound_1.l {:  return new TypeVariable(new Modifiers(), v, new List(), l);  :}
	;
	
List type_bound =
		EXTENDS reference_type.t {:  return new List().add(t);  :}
	|	EXTENDS reference_type.t additional_bound_list.l {:  l.insertChild(t,0); return l; :}
    ;
    
List type_bound_1 =
		EXTENDS reference_type_1.t {:  return new List().add(t);  :}
	|	EXTENDS reference_type.t additional_bound_list_1.l {:  l.insertChild(t,0); return l; :}
    ;
    
List additional_bound_list =
		additional_bound.b additional_bound_list.l {:  l.insertChild(b,0); return l; :}
	|	additional_bound.b {:  return new List().add(b);  :}
    ;
    
List additional_bound_list_1 =
		additional_bound.b additional_bound_list_1.l {:  l.insertChild(b,0); return l; :}
	|	additional_bound_1.b {:  return new List().add(b);  :}
    ;
    
Access additional_bound =
		AND interface_type.t {:  return t;  :}
	;
	
Access additional_bound_1 =
		AND reference_type_1.t {:  return t;  :}
	;

Opt class_body_opt = {: return new Opt(); :}
    |  class_body.b {:  return new Opt(b);  :};













Expr postfix_expression_nn =
    primary.p                                  {: return p; :}
  | postincrement_expression.e                 {: return e; :}
  | postdecrement_expression.e                 {: return e; :}
  ;
Expr unary_expression_nn =
    preincrement_expression.e                  {: return e; :}
  | predecrement_expression.e                  {: return e; :}
  | PLUS unary_expression.e                    {: return new PlusExpr(e); :}
  | MINUS unary_expression.e                   {: return new MinusExpr(e); :}
  | unary_expression_not_plus_minus_nn.e          {: return e; :}
  ;
Expr unary_expression_not_plus_minus_nn =
    postfix_expression_nn.e                       {: return e; :}
  | COMP unary_expression.e                    {: return new BitNotExpr(e); :}
  | NOT unary_expression.e                     {: return new LogNotExpr(e); :}
  | cast_expression.e                          {: return e; :}
  ;
Expr multiplicative_expression_nn =
    unary_expression_nn.e                                     {: return e; :}
  | name.e1 MULT unary_expression.e2  {: return new MulExpr(e1, e2); :}
  | multiplicative_expression_nn.e1 MULT unary_expression.e2  {: return new MulExpr(e1, e2); :}
  | name.e1 DIV unary_expression.e2   {: return new DivExpr(e1, e2); :}
  | multiplicative_expression_nn.e1 DIV unary_expression.e2   {: return new DivExpr(e1, e2); :}
  | name.e1 MOD unary_expression.e2   {: return new ModExpr(e1, e2); :}
  | multiplicative_expression_nn.e1 MOD unary_expression.e2   {: return new ModExpr(e1, e2); :}
  ;
Expr additive_expression_nn =
    multiplicative_expression_nn.e                                {: return e; :}
  | name.e1 PLUS multiplicative_expression.e2   {: return new AddExpr(e1, e2); :}
  | additive_expression_nn.e1 PLUS multiplicative_expression.e2   {: return new AddExpr(e1, e2); :}
  | name.e1 MINUS multiplicative_expression.e2  {: return new SubExpr(e1, e2); :}
  | additive_expression_nn.e1 MINUS multiplicative_expression.e2  {: return new SubExpr(e1, e2); :}
  ;
Expr shift_expression_nn =
    additive_expression_nn.e                               {: return e; :}
  | name.e1 LSHIFT additive_expression.e2   {: return new LShiftExpr(e1, e2); :}
  | shift_expression_nn.e1 LSHIFT additive_expression.e2   {: return new LShiftExpr(e1, e2); :}
  | name.e1 RSHIFT additive_expression.e2   {: return new RShiftExpr(e1, e2); :}
  | shift_expression_nn.e1 RSHIFT additive_expression.e2   {: return new RShiftExpr(e1, e2); :}
  | name.e1 URSHIFT additive_expression.e2  {: return new URShiftExpr(e1, e2); :}
  | shift_expression_nn.e1 URSHIFT additive_expression.e2  {: return new URShiftExpr(e1, e2); :}
  ;
Expr relational_expression_nn =
    shift_expression_nn.e                                  {: return e; :}
  | name.e1 LT shift_expression.e2     {: return new LTExpr(e1, e2); :}
  | shift_expression_nn.e1 LT shift_expression.e2     {: return new LTExpr(e1, e2); :}
  | name.e1 GT shift_expression.e2     {: return new GTExpr(e1, e2); :}
  | shift_expression_nn.e1 GT shift_expression.e2     {: return new GTExpr(e1, e2); :}
  | name.e1 LTEQ shift_expression.e2   {: return new LEExpr(e1, e2); :}
  | relational_expression_nn.e1 LTEQ shift_expression.e2   {: return new LEExpr(e1, e2); :}
  | name.e1 GTEQ shift_expression.e2   {: return new GEExpr(e1, e2); :}
  | relational_expression_nn.e1 GTEQ shift_expression.e2   {: return new GEExpr(e1, e2); :}
  | name.e INSTANCEOF reference_type.t {: return new InstanceOfExpr(e, t); :}
  | relational_expression_nn.e INSTANCEOF reference_type.t {: return new InstanceOfExpr(e, t); :}
  ;
Expr equality_expression_nn =
    relational_expression_nn.e                               {: return e; :}
  | name.e1 EQEQ relational_expression.e2  {: return new EQExpr(e1, e2); :}
  | equality_expression_nn.e1 EQEQ relational_expression.e2  {: return new EQExpr(e1, e2); :}
  | name.e1 NOTEQ relational_expression.e2 {: return new NEExpr(e1, e2); :}
  | equality_expression_nn.e1 NOTEQ relational_expression.e2 {: return new NEExpr(e1, e2); :}
  ;
Expr and_expression_nn =
    equality_expression_nn.e                               {: return e; :}
  | name.e1 AND equality_expression.e2        {: return new AndBitwiseExpr(e1, e2); :}
  | and_expression_nn.e1 AND equality_expression.e2        {: return new AndBitwiseExpr(e1, e2); :}
  ;
Expr exclusive_or_expression_nn =
    and_expression_nn.e                                    {: return e; :}
  | name.e1 XOR and_expression.e2    {: return new XorBitwiseExpr(e1, e2); :}
  | exclusive_or_expression_nn.e1 XOR and_expression.e2    {: return new XorBitwiseExpr(e1, e2); :}
  ;
Expr inclusive_or_expression_nn =
    exclusive_or_expression_nn.e                                {: return e; :}
  | name.e1 OR exclusive_or_expression.e2 {: return new OrBitwiseExpr(e1, e2); :}
  | inclusive_or_expression_nn.e1 OR exclusive_or_expression.e2 {: return new OrBitwiseExpr(e1, e2); :}
  ;
Expr conditional_and_expression_nn =
    inclusive_or_expression_nn.e                                       {: return e; :}
  | name.e1 ANDAND inclusive_or_expression.e2 {: return new AndLogicalExpr(e1, e2); :}
  | conditional_and_expression_nn.e1 ANDAND inclusive_or_expression.e2 {: return new AndLogicalExpr(e1, e2); :}
  ;
Expr conditional_or_expression_nn =
    conditional_and_expression_nn.e                                    {: return e; :}
  | name.e1 OROR conditional_and_expression.e2 {: return new OrLogicalExpr(e1, e2); :}
  | conditional_or_expression_nn.e1 OROR conditional_and_expression.e2 {: return new OrLogicalExpr(e1, e2); :}
  ;
Expr conditional_expression_nn =
    conditional_or_expression_nn.c                                                        {: return c; :}
  | name.c QUESTION expression.e1 COLON conditional_expression.e2 {: return new ConditionalExpr(c, e1, e2); :}
  | conditional_or_expression_nn.c QUESTION expression.e1 COLON conditional_expression.e2 {: return new ConditionalExpr(c, e1, e2); :}
  ;
Expr assignment_expression_nn =
    conditional_expression_nn.c {: return c; :}
  | assignment.a {: return a; :}
  ;

Expr expression_nn =
    assignment_expression_nn
  ;

