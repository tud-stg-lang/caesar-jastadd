%header {:
 package parser;
 import AST.*;
:};
%embed {:
  public static class SourceError extends Error {
    public SourceError(String msg) {
      super(msg);
    }
  }
  class Events extends Parser.Events {
    public void syntaxError(Symbol token) {
      StringBuffer s = new StringBuffer();
      s.append(token.getLine(token.getStart()) + ", " + token.getColumn(token.getStart()) + "\n");
      s.append("  *** Syntactic error: unexpected token " + Terminals.NAMES[token.getId()]);
      throw new SourceError(s.toString());
        //super.syntaxError(token);
        //throw new RuntimeException(token.getLine(token.getStart()) + ", " + token.getColumn(token.getStart()) + ": Syntax Error");
    }
    public void scannerError(Scanner.Exception e) {
      StringBuffer s = new StringBuffer();
      s.append(e.line + ", " + e.column + "\n");
      s.append("  *** Lexical error: " + e.getMessage());
      throw new SourceError(s.toString());
        //super.scannerError(e);
        //throw new RuntimeException("Unexpected token");
    }

  }

        {
            report = new Events(); // Use error handler in parser
        }
:};

CompilationUnit goal =
    compilation_unit.cu      {: return cu; :}
  ;
      
Expr literal =
    INTEGER_LITERAL.i        {: return new IntegerLiteral(i); :}
  | LONG_LITERAL.l           {: return new LongLiteral(l); :}
  | FLOATING_POINT_LITERAL.f {: return new FloatingPointLiteral(f); :}
  | DOUBLE_LITERAL.d         {: return new DoubleLiteral(d); :}
  | BOOLEAN_LITERAL.b        {: return new BooleanLiteral(b); :}
  | CHARACTER_LITERAL.c      {: return new CharacterLiteral(c); :}
  | STRING_LITERAL.s         {: return new StringLiteral(s); :}
  | NULL_LITERAL             {: return new NullLiteral("null"); :}
  ;
Access type =
    primitive_type.t         {: return t; :}
  | reference_type.t         {: return t; :}
  ;
Access primitive_type =
    numeric_type.t           {: return t; :}
  | BOOLEAN                  {: return new PrimitiveTypeAccess("boolean"); :}
  ;
Access numeric_type =
    integral_type.t          {: return t; :}
  | floating_point_type.t    {: return t; :}
  ;
Access integral_type =
    BYTE                     {: return new PrimitiveTypeAccess("byte"); :}
  | SHORT                    {: return new PrimitiveTypeAccess("short"); :}
  | INT                      {: return new PrimitiveTypeAccess("int"); :}
  | LONG                     {: return new PrimitiveTypeAccess("long"); :}
  | CHAR                     {: return new PrimitiveTypeAccess("char"); :}
  ;
Access floating_point_type =
    FLOAT                    {: return new PrimitiveTypeAccess("float"); :}
  | DOUBLE                   {: return new PrimitiveTypeAccess("double"); :}
  ;
Access reference_type =
    class_or_interface_type.t {: return t; :}
  | array_type.t              {: return t; :}
  ;
Access class_or_interface_type =
    name.n                    {: return n; :}
  ;
Access class_type =
    class_or_interface_type.n {: return n; :}
  ;
Access interface_type =
    class_or_interface_type.n {: return n; :}
  ;
Access array_type =
    primitive_type.t dims.d   {: return new ArrayTypeAccess(t, d.getNumChild()); :}
  | name.n dims.d             {: return new ArrayTypeAccess(n, d.getNumChild()); :}
  ;
Access name =
    simple_name.s             {: return s; :}
  | qualified_name.q          {: return q; :}
  ;
Access simple_name =
    IDENTIFIER.i              {: return new ParseName(i); :}
  ;
Access qualified_name =
    name.n DOT IDENTIFIER.i   {: return n.qualifiesAccess(new ParseName(i)); :}
  ;
CompilationUnit compilation_unit =
    package_declaration.p import_declarations.i type_declarations.t {: return new CompilationUnit(p.getID(), i, t); :}
  |                       import_declarations.i type_declarations.t {: return new CompilationUnit("", i, t); :}
  | package_declaration.p                       type_declarations.t {: return new CompilationUnit(p.getID(), new List(), t); :}
  |                                             type_declarations.t {: return new CompilationUnit("", new List(), t); :}
  | package_declaration.p import_declarations.i                     {: return new CompilationUnit(p.getID(), i, new List()); :}
  |                       import_declarations.i                     {: return new CompilationUnit("", i, new List()); :}
  | package_declaration.p                                           {: return new CompilationUnit(p.getID(), new List(), new List()); :}
  |                                                                 {: return new CompilationUnit("", new List(), new List()); :}
  ;
List import_declarations =
    import_declaration.i                       {: return new List().add(i); :}
  | import_declarations.l import_declaration.i {: return l.add(i); :}
  ;
List type_declarations =
    type_declaration.t                         {: return !(t instanceof EmptyType) ? new List().add(t) : new List() ; :}
  | type_declarations.l type_declaration.t     {: return !(t instanceof EmptyType) ? l.add(t) : l; :}
  ;
IdUse package_declaration =
    PACKAGE name_decl.n SEMICOLON              {: return n; :}
  ;
IdUse name_decl =
    simple_name_decl.s        {: return s; :}
  | qualified_name_decl.q     {: return q; :}
  ;
IdUse simple_name_decl =
    IDENTIFIER.i              {: return new IdUse(i); :}
  ;
IdUse qualified_name_decl =
    name_decl.n DOT IDENTIFIER.i {: return new IdUse(n.getID() + "." + i); :}
  ;
ImportDecl import_declaration =
    single_type_import_declaration.s           {: return s; :}
  | type_import_on_demand_declaration.t        {: return t; :}
  ;
ImportDecl single_type_import_declaration =
    IMPORT name.n SEMICOLON                    {: return new SingleTypeImportDecl(n); :}
  ;
ImportDecl type_import_on_demand_declaration =
    IMPORT name.n DOT MULT SEMICOLON           {: return new TypeImportOnDemandDecl(n); :}
  ;
TypeDecl type_declaration =
    class_declaration.c                        {: return c; :}
  | interface_declaration.i                    {: return i; :}
  | SEMICOLON                                  {: return new EmptyType(new Modifiers(), "EmptyType", new Opt(), new List()); :}
  ;
Modifiers modifiers =
    modifier.m                                 {: Modifiers ms = new Modifiers(); ms.addModifier(m); return ms; :}
  | modifiers.l modifier.m                     {: l.addModifier(m); return l; :}
  ;
Modifier modifier =
    PUBLIC                                     {: return new Modifier("public"); :}
  | PROTECTED                                  {: return new Modifier("protected"); :}
  | PRIVATE                                    {: return new Modifier("private"); :}
  | STATIC                                     {: return new Modifier("static"); :}
  | ABSTRACT                                   {: return new Modifier("abstract"); :}
  | FINAL                                      {: return new Modifier("final"); :}
  | NATIVE                                     {: return new Modifier("native"); :}
  | SYNCHRONIZED                               {: return new Modifier("synchronized"); :}
  | TRANSIENT                                  {: return new Modifier("transient"); :}
  | VOLATILE                                   {: return new Modifier("volatile"); :}
  | STRICTFP                                   {: return new Modifier("strictfp"); :}
  ;
ClassDecl class_declaration =
    modifiers.m CLASS IDENTIFIER.id super.s interfaces.i class_body.b 
                                               {: return new ClassDecl(m, id, s, i, b); :}
  |             CLASS IDENTIFIER.id super.s interfaces.i class_body.b 
                                               {: return new ClassDecl(new Modifiers(), id, s, i, b); :}
  | modifiers.m CLASS IDENTIFIER.id         interfaces.i class_body.b 
                                               {: return new ClassDecl(m, id, new Opt(), i, b); :}
  |             CLASS IDENTIFIER.id         interfaces.i class_body.b 
                                               {: return new ClassDecl(new Modifiers(), id, new Opt(), i, b); :}
  | modifiers.m CLASS IDENTIFIER.id super.s              class_body.b 
                                               {: return new ClassDecl(m, id, s, new List(), b); :}
  |             CLASS IDENTIFIER.id super.s              class_body.b 
                                               {: return new ClassDecl(new Modifiers(), id, s, new List(), b); :}
  | modifiers.m CLASS IDENTIFIER.id                      class_body.b 
                                               {: return new ClassDecl(m, id, new Opt(), new List(), b); :}
  |             CLASS IDENTIFIER.id                      class_body.b 
                                               {: return new ClassDecl(new Modifiers(), id, new Opt(), new List(), b); :}
  ;
Opt super =
    EXTENDS class_type.c                       {: return new Opt(c); :}
  ;
List interfaces =
    IMPLEMENTS interface_type_list.i           {: return i; :}
  ;
List interface_type_list =
    interface_type.i                              {: return new List().add(i); :}
  | interface_type_list.l COMMA interface_type.i  {: return l.add(i); :}
  ;
List class_body =
    LBRACE class_body_declarations.c RBRACE    {: return c; :}
  | LBRACE                           RBRACE    {: return new List(); :}
  ;
List class_body_declarations =
    class_body_declaration.c                           {: return new List().add(c); :}
  | class_body_declarations.l class_body_declaration.c {: return l.add(c); :}
  ;
BodyDecl class_body_declaration =
    class_member_declaration.c                 {: return c; :}
  | instance_initializer.i                     {: return i; :}
  | static_initializer.si                      {: return si; :}
  | constructor_declaration.c                  {: return c; :}
  ;
BodyDecl class_member_declaration =
    field_declaration.f                        {: return f; :}
  | method_declaration.m                       {: return m; :}
  | class_declaration.c                        {: return new MemberClassDecl(c); :}
  | interface_declaration.i                    {: return new MemberInterfaceDecl(i); :}
  | SEMICOLON                                  {: return new InstanceInitializer(new Block()); :}
  ;
BodyDecl field_declaration =
    modifiers.m type.t variable_declarators.v SEMICOLON {: return new FieldDecl(m, t, v); :}
  |             type.t variable_declarators.v SEMICOLON {: return new FieldDecl(new Modifiers(), t, v); :}
  ;
List variable_declarators =
    variable_declarator.v                              {: return new List().add(v); :}
  | variable_declarators.l COMMA variable_declarator.v {: return l.add(v); :}
  ;
VariableDecl variable_declarator =
    variable_declarator_id.v                           {: return v; :}
  | variable_declarator_id.v EQ variable_initializer.i {: v.setInit(i); return v; :}
  ;
VariableDecl variable_declarator_id =
    IDENTIFIER.id                              {: return new VariableDecl(id, new List(), new Opt()); :}
  | variable_declarator_id.v LBRACK RBRACK     {: v.addEmptyBracket(new EmptyBracket()); return v; :}
  ;
Expr variable_initializer =
    expression.e                               {: return e; :}
  | array_initializer.a                        {: return a; :}
  ;
MethodDecl method_declaration =
    method_header.m method_body.b              {: m.setBlockOpt(b); return m; :}
  ;
      
MethodDecl method_header =
    modifiers.m type.t method_declarator.d throws.tl 
                                                 {: d.setModifiers(m); d.setTypeAccess(t); d.setExceptionList(tl); return d; :}
  |             type.t method_declarator.d throws.tl 
                                                 {: d.setModifiers(new Modifiers()); d.setTypeAccess(t); d.setExceptionList(tl); return d; :}
  | modifiers.m type.t method_declarator.d 
                                                 {: d.setModifiers(m); d.setTypeAccess(t); d.setExceptionList(new List()); return d; :}
  |             type.t method_declarator.d 
                                      {: d.setModifiers(new Modifiers()); d.setTypeAccess(t); d.setExceptionList(new List()); return d; :}
  | modifiers.m VOID method_declarator.d throws.tl
    {: d.setModifiers(m); d.setTypeAccess(new PrimitiveTypeAccess("void")); d.setExceptionList(tl); return d; :}
  |             VOID method_declarator.d throws.tl
    {: d.setModifiers(new Modifiers()); d.setTypeAccess(new PrimitiveTypeAccess("void")); d.setExceptionList(tl); return d; :}
  | modifiers.m VOID method_declarator.d 
    {: d.setModifiers(m); d.setTypeAccess(new PrimitiveTypeAccess("void")); d.setExceptionList(new List()); return d; :}
  |             VOID method_declarator.d
    {: d.setModifiers(new Modifiers()); d.setTypeAccess(new PrimitiveTypeAccess("void")); d.setExceptionList(new List()); return d; :}
  ;
                                                                
MethodDecl method_declarator =
    IDENTIFIER.id LPAREN formal_parameter_list.l RPAREN {: return new MethodDecl(null, null, id, l, new List(), null, new Opt()); :}
  | IDENTIFIER.id LPAREN                         RPAREN {: return new MethodDecl(null, null, id, new List(), new List(), null, new Opt()); :}
  | method_declarator.m LBRACK RBRACK                   {: m.addEmptyBracket(new EmptyBracket()); return m; :}
  ;
List formal_parameter_list =
    formal_parameter.f                                  {: return new List().add(f); :}
  | formal_parameter_list.l COMMA formal_parameter.f    {: return l.add(f); :}
  ;
ParameterDeclaration formal_parameter =
                type.t variable_declarator_id.v {: return new ParameterDeclaration(new Modifiers(), t, v.getID(), v.getEmptyBracketList()); :}
  | modifiers.m type.t variable_declarator_id.v {: return new ParameterDeclaration(m, t, v.getID(), v.getEmptyBracketList()); :}
  ;
List throws =
    THROWS class_type_list.l                   {: return l; :}
  ;
List class_type_list =
    class_type.c                               {: return new List().add(c); :}
  | class_type_list.l COMMA class_type.c       {: return l.add(c); :}
  ;
Opt method_body =
    block.b                                    {: return new Opt(b); :}
  | SEMICOLON                                  {: return new Opt(); :}
  ;
StaticInitializer static_initializer =
    STATIC block.b                             {: return new StaticInitializer(b); :}
  ;
InstanceInitializer instance_initializer =
    block.b                                    {: return new InstanceInitializer(b); :}
  ;
ConstructorDecl constructor_declaration =
    modifiers.m IDENTIFIER.id LPAREN formal_parameter_list.pl RPAREN throws.tl constructor_body.b
    {: b.setModifiers(m); b.setID(id); b.setParameterList(pl); b.setExceptionList(tl); return b; :}
  |             IDENTIFIER.id LPAREN formal_parameter_list.pl RPAREN throws.tl constructor_body.b
    {: b.setID(id); b.setParameterList(pl); b.setExceptionList(tl); return b; :}
  | modifiers.m IDENTIFIER.id LPAREN                          RPAREN throws.tl constructor_body.b
    {: b.setModifiers(m); b.setID(id); b.setExceptionList(tl); return b; :}
  |             IDENTIFIER.id LPAREN                          RPAREN throws.tl constructor_body.b
    {: b.setID(id); b.setExceptionList(tl); return b; :}
  | modifiers.m IDENTIFIER.id LPAREN formal_parameter_list.pl RPAREN           constructor_body.b
    {: b.setModifiers(m); b.setID(id); b.setParameterList(pl); return b; :}
  |             IDENTIFIER.id LPAREN formal_parameter_list.pl RPAREN           constructor_body.b
    {: b.setID(id); b.setParameterList(pl); return b; :}
  | modifiers.m IDENTIFIER.id LPAREN                          RPAREN           constructor_body.b
    {: b.setModifiers(m); b.setID(id); return b; :}
  |             IDENTIFIER.id LPAREN                          RPAREN           constructor_body.b
    {: b.setID(id); return b; :}
 ;
ConstructorDecl constructor_body =
		LBRACE explicit_constructor_invocation.c block_statements.l RBRACE
    {: return new ConstructorDecl(new Modifiers(), null, new List(), new List(), new Opt(c), new Block(l)); :}
	|	LBRACE explicit_constructor_invocation.c RBRACE
    {: return new ConstructorDecl(new Modifiers(), null, new List(), new List(), new Opt(c), new Block(new List())); :}
	|	LBRACE block_statements.l RBRACE
    {: return new ConstructorDecl(new Modifiers(), null, new List(), new List(), new Opt(), new Block(l)); :}
	|	LBRACE RBRACE
    {: return new ConstructorDecl(new Modifiers(), null, new List(), new List(), new Opt(), new Block(new List())); :}
	;
ExprStmt explicit_constructor_invocation =
    THIS LPAREN argument_list_opt.l RPAREN SEMICOLON 
    {: return new ExprStmt(new ConstructorAccess(l, "this")); :}
  | SUPER LPAREN argument_list_opt.l RPAREN SEMICOLON 
    {: return new ExprStmt(new SuperConstructorAccess(l, "super")); :}
  | primary.p DOT SUPER LPAREN argument_list_opt.l RPAREN SEMICOLON
    {: return new ExprStmt(p.qualifiesAccess(new SuperConstructorAccess(l, "super"))); :}
  | name.n DOT SUPER LPAREN argument_list_opt.l RPAREN SEMICOLON
    {: return new ExprStmt(n.qualifiesAccess(new SuperConstructorAccess(l, "super"))); :}
  ;
InterfaceDecl interface_declaration =
    modifiers.m INTERFACE IDENTIFIER.id extends_interfaces.i interface_body.b {: return new InterfaceDecl(m, id, i, b); :}
  |             INTERFACE IDENTIFIER.id extends_interfaces.i interface_body.b {: return new InterfaceDecl(new Modifiers(), id, i, b); :}
  | modifiers.m INTERFACE IDENTIFIER.id                      interface_body.b {: return new InterfaceDecl(m, id, new List(), b); :}
  |             INTERFACE IDENTIFIER.id                      interface_body.b {: return new InterfaceDecl(new Modifiers(), id, new List(), b); :}
  ;
List extends_interfaces =
    EXTENDS interface_type.i                    {: return new List().add(i); :}
  | extends_interfaces.l COMMA interface_type.i {: return l.add(i); :}
  ;
    
List interface_body =
    LBRACE interface_member_declarations.i RBRACE  {: return i; :}
  | LBRACE                                 RBRACE  {: return new List(); :}
  ;   
List interface_member_declarations =
    interface_member_declaration.i                                  {: return new List().add(i); :}
  | interface_member_declarations.l interface_member_declaration.i  {: return l.add(i); :}
  ;
BodyDecl interface_member_declaration =
    constant_declaration.c                     {: return c; :}
  | abstract_method_declaration.a              {: return a; :}
  | class_declaration.c                        {: return new MemberClassDecl(c); :}
  | interface_declaration.i                    {: return new MemberInterfaceDecl(i); :}
  | SEMICOLON                                  {: return new StaticInitializer(new Block()); :}
  ;
BodyDecl constant_declaration =
    field_declaration.f                        {: return f; :}
  ;
BodyDecl abstract_method_declaration =
    method_header.m SEMICOLON                  {: return m; :}
  ;
ArrayInit array_initializer =
    LBRACE variable_initializers.v COMMA RBRACE   {: return new ArrayInit(v); :}
  | LBRACE variable_initializers.v RBRACE         {: return new ArrayInit(v); :}
  | LBRACE COMMA RBRACE                           {: return new ArrayInit(new List()); :}
  | LBRACE RBRACE                                 {: return new ArrayInit(new List()); :}
  ;
List variable_initializers =
    variable_initializer.v                                {: return new List().add(v); :}
  | variable_initializers.l COMMA variable_initializer.v  {: return l.add(v); :}
  ;
Block block =
    LBRACE block_statements.l RBRACE {: return new Block(l); :}
  | LBRACE                    RBRACE {: return new Block(new List()); :}
  ;
List block_statements =
    block_statement.b                     {: return new List().add(b); :}
  | block_statements.l block_statement.b  {: return l.add(b); :}
  ;
Stmt block_statement =
    local_variable_declaration_statement.l  {: return l; :}
  | class_declaration.c                     {: return new LocalClassDeclStmt(c); :}
  | statement.s                             {: return s; :}
  ;
VarDeclStmt local_variable_declaration_statement =
    local_variable_declaration.l SEMICOLON  {: return l; :}
  ;
VarDeclStmt local_variable_declaration =
                 type.t variable_declarators.l {: return new VarDeclStmt(new Modifiers(), t, l); :}
  |  modifiers.m type.t variable_declarators.l {: return new VarDeclStmt(m, t, l); :}
  ;
Stmt statement =
    statement_without_trailing_substatement.s  {: return s; :}
  | labeled_statement.l                        {: return l; :}
  | if_then_statement.i                        {: return i; :}
  | if_then_else_statement.i                   {: return i; :}
  | while_statement.w                          {: return w; :}
  | for_statement.f                            {: return f; :}
  ;
Stmt statement_without_trailing_substatement =
    block.b                                    {: return b; :}
  | empty_statement.e                          {: return e; :}
  | expression_statement.e                     {: return e; :}
  | switch_statement.s                         {: return s; :}
  | do_statement.d                             {: return d; :}
  | break_statement.b                          {: return b; :}
  | continue_statement.c                       {: return c; :}
  | return_statement.r                         {: return r; :}
  | synchronized_statement.s                   {: return s; :}
  | throw_statement.t                          {: return t; :}
  | try_statement.t                            {: return t; :}
  | assert_statement.a                         {: return a; :}
  ;
Stmt statement_no_short_if =
    statement_without_trailing_substatement.s  {: return s; :}
  | labeled_statement_no_short_if.l            {: return l; :}
  | if_then_else_statement_no_short_if.i       {: return i; :}
  | while_statement_no_short_if.w              {: return w; :}
  | for_statement_no_short_if.f                {: return f; :}
  ;
IfStmt if_then_statement =
    IF LPAREN expression.e RPAREN statement.s  {: return new IfStmt(e, s, new Opt()); :}
  ;
IfStmt if_then_else_statement =
    IF LPAREN expression.e RPAREN statement_no_short_if.t ELSE statement.els {: return new IfStmt(e, t, new Opt(els)); :}
  ;
IfStmt if_then_else_statement_no_short_if =
    IF LPAREN expression.e RPAREN statement_no_short_if.t ELSE statement_no_short_if.els {: return new IfStmt(e, t, new Opt(els)); :}
  ;
EmptyStmt empty_statement =
    SEMICOLON                                  {: return new EmptyStmt(); :}
  ;
LabeledStmt labeled_statement =
    IDENTIFIER.id COLON statement.s            {: return new LabeledStmt(id, s); :}
  ;
LabeledStmt labeled_statement_no_short_if =
    IDENTIFIER.id COLON statement_no_short_if.s {: return new LabeledStmt(id, s); :}
  ;
ExprStmt expression_statement =
    statement_expression.e SEMICOLON           {: return e; :}
  ;
ExprStmt statement_expression =
    assignment.a                               {: return new ExprStmt(a); :}
  | preincrement_expression.e                  {: return new ExprStmt(e); :}
  | predecrement_expression.e                  {: return new ExprStmt(e); :}
  | postincrement_expression.e                 {: return new ExprStmt(e); :}
  | postdecrement_expression.e                 {: return new ExprStmt(e); :}
  | method_invocation.i                        {: return new ExprStmt(i); :}
  | class_instance_creation_expression.e       {: return new ExprStmt(e); :}
  ;
SwitchStmt switch_statement =
    SWITCH LPAREN expression.e RPAREN switch_block.l {: return new SwitchStmt(e, l); :}
  ;
List switch_block =
    LBRACE switch_block_statement_groups.l switch_labels.s RBRACE 
                        {: for(int ii = 0; ii < s.getNumChild(); ii++) l.add(s.getChild(ii)); return l; :}
  | LBRACE switch_block_statement_groups.l RBRACE   {: return l; :}
  | LBRACE switch_labels.l RBRACE              {: return l; :}
  | LBRACE RBRACE                              {: return new List(); :}
  ;
List switch_block_statement_groups =
    switch_block_statement_group.g             {: return g; :}
  | switch_block_statement_groups.l switch_block_statement_group.g 
      {: for(int ii = 0; ii < g.getNumChild(); ii++)
           l.add(g.getChild(ii));
         return l; :}
  ;
List switch_block_statement_group =
    switch_labels.l block_statements.bl 
    {: ((Case)l.getChild(l.getNumChild()-1)).setStmtList(bl);
       return l; :}
  ;
List switch_labels =
    switch_label.s                             {: return new List().add(s); :}
  | switch_labels.l switch_label.s             {: return l.add(s); :}
  ;
Case switch_label =
    CASE constant_expression.e COLON           {: return new ConstCase(e, new List()); :}
  | DEFAULT COLON                              {: return new DefaultCase(new List()); :}
  ;
WhileStmt while_statement =
    WHILE LPAREN expression.e RPAREN statement.s {: return new WhileStmt(e, s); :}
  ;
WhileStmt while_statement_no_short_if =
    WHILE LPAREN expression.e RPAREN statement_no_short_if.s {: return new WhileStmt(e, s); :}
  ;
DoStmt do_statement =
    DO statement.s WHILE LPAREN expression.e RPAREN SEMICOLON {: return new DoStmt(s, e); :}
  ;
ForStmt for_statement =
    FOR LPAREN for_init.i SEMICOLON expression.e SEMICOLON for_update.u RPAREN statement.s {: return new ForStmt(i, new Opt(e), u, s); :}
  | FOR LPAREN            SEMICOLON expression.e SEMICOLON for_update.u RPAREN statement.s {: return new ForStmt(new List(), new Opt(e), u, s); :}
  | FOR LPAREN for_init.i SEMICOLON              SEMICOLON for_update.u RPAREN statement.s {: return new ForStmt(i, new Opt(), u, s); :}
  | FOR LPAREN            SEMICOLON              SEMICOLON for_update.u RPAREN statement.s {: return new ForStmt(new List(), new Opt(), u, s); :}
  | FOR LPAREN for_init.i SEMICOLON expression.e SEMICOLON              RPAREN statement.s {: return new ForStmt(i, new Opt(e), new List(), s); :}
  | FOR LPAREN            SEMICOLON expression.e SEMICOLON              RPAREN statement.s {: return new ForStmt(new List(), new Opt(e), new List(), s); :}
  | FOR LPAREN for_init.i SEMICOLON              SEMICOLON              RPAREN statement.s {: return new ForStmt(i, new Opt(), new List(), s); :}
  | FOR LPAREN            SEMICOLON              SEMICOLON              RPAREN statement.s {: return new ForStmt(new List(), new Opt(), new List(), s); :}
  ;
ForStmt for_statement_no_short_if =
    FOR LPAREN for_init.i SEMICOLON expression.e SEMICOLON for_update.u RPAREN statement_no_short_if.s {: return new ForStmt(i, new Opt(e), u, s); :}
  | FOR LPAREN            SEMICOLON expression.e SEMICOLON for_update.u RPAREN statement_no_short_if.s {: return new ForStmt(new List(), new Opt(e), u, s); :}
  | FOR LPAREN for_init.i SEMICOLON              SEMICOLON for_update.u RPAREN statement_no_short_if.s {: return new ForStmt(i, new Opt(), u, s); :}
  | FOR LPAREN            SEMICOLON              SEMICOLON for_update.u RPAREN statement_no_short_if.s {: return new ForStmt(new List(), new Opt(), u, s); :}
  | FOR LPAREN for_init.i SEMICOLON expression.e SEMICOLON              RPAREN statement_no_short_if.s {: return new ForStmt(i, new Opt(e), new List(), s); :}
  | FOR LPAREN            SEMICOLON expression.e SEMICOLON              RPAREN statement_no_short_if.s {: return new ForStmt(new List(), new Opt(e), new List(), s); :}
  | FOR LPAREN for_init.i SEMICOLON              SEMICOLON              RPAREN statement_no_short_if.s {: return new ForStmt(i, new Opt(), new List(), s); :}
  | FOR LPAREN            SEMICOLON              SEMICOLON              RPAREN statement_no_short_if.s {: return new ForStmt(new List(), new Opt(), new List(), s); :}
  ;
List for_init =
    statement_expression_list.l        {: return l; :}
  | local_variable_declaration.d       {: return new List().add(d); :};
List for_update =
    statement_expression_list.l        {: return l; :}
  ;
List statement_expression_list =
    statement_expression.e                                   {: return new List().add(e); :}
  | statement_expression_list.l COMMA statement_expression.e {: return l.add(e); :}
  ;
BreakStmt break_statement =
    BREAK IDENTIFIER.id SEMICOLON              {: return new BreakStmt(id); :}
  | BREAK               SEMICOLON              {: return new BreakStmt(""); :}
  ; 
ContinueStmt continue_statement =
    CONTINUE IDENTIFIER.id SEMICOLON           {: return new ContinueStmt(id); :}
  | CONTINUE               SEMICOLON           {: return new ContinueStmt(""); :}
  ;
ReturnStmt return_statement =
    RETURN expression.e SEMICOLON              {: return new ReturnStmt(new Opt(e)); :}
  | RETURN              SEMICOLON              {: return new ReturnStmt(new Opt()); :}
  ;
ThrowStmt throw_statement =
    THROW expression.e SEMICOLON               {: return new ThrowStmt(e); :}
  ;
SynchronizedStmt synchronized_statement =
    SYNCHRONIZED LPAREN expression.e RPAREN block.b {: return new SynchronizedStmt(e, b); :}
  ;
TryStmt try_statement =
    TRY block.b catches.c                      {: return new TryStmt(b, c, new Opt()); :}
  | TRY block.b catches.c finally.f            {: return new TryStmt(b, c, new Opt(f)); :}
  | TRY block.b           finally.f            {: return new TryStmt(b, new List(), new Opt(f)); :}
  ;
List catches =
    catch_clause.c                             {: return new List().add(c); :}
  | catches.l catch_clause.c                   {: return l.add(c); :}
  ;
CatchClause catch_clause =
    CATCH LPAREN formal_parameter.p RPAREN block.b {: return new CatchClause(p, b); :}
  ;
Block finally =
    FINALLY block.b {: return b; :}
  ;
AssertStmt assert_statement =
    ASSERT expression.e                    SEMICOLON {: return new AssertStmt(e, new Opt()); :}
  | ASSERT expression.e COLON expression.s SEMICOLON {: return new AssertStmt(e, new Opt(s)); :}
  ;
Expr primary =
    primary_no_new_array.p                     {: return p; :}
  | array_creation_init.a                      {: return a; :}
  | array_creation_uninit.a                    {: return a; :}
  ;
Expr primary_no_new_array =
    literal.l                                  {: return l; :}
  | primitive_type.n DOT CLASS                 {: return n.qualifiesAccess(new ClassAccess()); :}
  | primitive_type.n dims.d DOT CLASS          {: return new ArrayTypeAccess(n, d.getNumChild()).qualifiesAccess(new ClassAccess()); :}
  | name.n DOT CLASS                           {: return n.qualifiesAccess(new ClassAccess()); :}
  | name.n dims.d DOT CLASS                    {: return new ArrayTypeAccess(n, d.getNumChild()).qualifiesAccess(new ClassAccess()); :}
  | VOID DOT CLASS                             {: return new PrimitiveTypeAccess("void").qualifiesAccess(new ClassAccess()); :}
  | THIS                                       {: return new ThisAccess("this"); :}
  | name.n DOT THIS                            {: return n.qualifiesAccess(new ThisAccess("this")); :}
  | LPAREN expression.e RPAREN                 {: return new ParExpr(e); :}
  | LPAREN name.n RPAREN                       {: return new ParExpr(n); :}
  | class_instance_creation_expression.c       {: return c; :}
  | field_access.f                             {: return f; :}
  | method_invocation.m                        {: return m; :}
  | array_access.a                             {: return a; :}
  ;
Expr class_instance_creation_expression =
    NEW class_or_interface_type.t LPAREN argument_list_opt.l RPAREN 
    {: return new ClassInstanceExpr(t, l, new Opt()); :}
  | primary.n DOT NEW IDENTIFIER.id LPAREN argument_list_opt.l RPAREN
    {: return n.qualifiesAccess(new ClassInstanceExpr(new ParseName(id), l, new Opt())); :}
  | name.n DOT NEW IDENTIFIER.id LPAREN argument_list_opt.l RPAREN
    {: return n.qualifiesAccess(new ClassInstanceExpr(new ParseName(id), l, new Opt())); :}
    
  | NEW class_or_interface_type.t LPAREN argument_list_opt.l RPAREN subclass_body.b 
    {: return new ClassInstanceExpr(t, l, b); :}
  | primary.n DOT NEW IDENTIFIER.id LPAREN argument_list_opt.l RPAREN subclass_body.b
    {: return n.qualifiesAccess(new ClassInstanceExpr(new ParseName(id), l, b )); :}
  | name.n DOT NEW IDENTIFIER.id LPAREN argument_list_opt.l RPAREN subclass_body.b
    {: return n.qualifiesAccess(new ClassInstanceExpr(new ParseName(id), l, b)); :}
  ;
Opt subclass_body =
    class_body.b                               {: return new Opt(new AnonymousDecl(new Modifiers(), "Anonymous", b)); :}
  ;
List argument_list_opt =
                                               {: return new List(); :}
  | argument_list.a                            {: return a; :}
  ;
List argument_list =
    expression.e                               {: return new List().add(e); :}
  | argument_list.l COMMA expression.e         {: return l.add(e); :}
  ;

Expr array_creation_uninit =
    NEW primitive_type.t dim_exprs.d           {: return new ArrayCreationExpr(t, d, new Opt()); :}
  | NEW primitive_type.t dim_exprs.d dims.e 
         {: for(int i = 0; i < e.getNumChild(); i++) d.add(e.getChildNoTransform(i)); return new ArrayCreationExpr(t, d, new Opt()); :}
  | NEW class_or_interface_type.t dim_exprs.d  {: return new ArrayCreationExpr(t, d, new Opt()); :}
  | NEW class_or_interface_type.t dim_exprs.d dims.e 
         {: for(int i = 0; i < e.getNumChild(); i++) d.add(e.getChildNoTransform(i)); return new ArrayCreationExpr(t, d, new Opt()); :}
  ;
Expr array_creation_init =
    NEW primitive_type.t dims.d array_initializer.i           {: return new ArrayCreationExpr(t, d, new Opt(i)); :}
  | NEW class_or_interface_type.t dims.d array_initializer.i  {: return new ArrayCreationExpr(t, d, new Opt(i)); :}
  ;
List dim_exprs =
    dim_expr.e                                 {: return new List().add(e); :}
  | dim_exprs.l dim_expr.e                     {: return l.add(e); :}
  ;
Dims dim_expr =
    LBRACK expression.e RBRACK                 {: return new Dims(new Opt(e)); :}
  ;
List dims =
    LBRACK RBRACK                              {: return new List().add(new Dims(new Opt())); :}
  | dims.l LBRACK RBRACK                       {: return l.add(new Dims(new Opt())); :}
  ;
Access field_access =
    primary.p DOT IDENTIFIER.id                {: return p.qualifiesAccess(new ParseName(id)); :}
  | SUPER DOT IDENTIFIER.id 
    {: return new SuperAccess("super").qualifiesAccess(new ParseName(id)); :}
  | name.n DOT SUPER DOT IDENTIFIER.id
    {: return n.qualifiesAccess(new SuperAccess("super")).qualifiesAccess(new ParseName(id)); :}
  ;
Access method_invocation =
      name.n LPAREN argument_list_opt.l RPAREN {: 
                                                             if(n instanceof AbstractDot) {    
                                                               AbstractDot d = (AbstractDot)n; 
                                                               ParseName pn = (ParseName)d.extractLast();
                                                               d.replaceLast(new MethodAccess(l, pn.getID()));
                                                               return d;
                                                             }
                                                             else {
                                                               ParseName pn = (ParseName)n;
                                                               return new MethodAccess(l, pn.getID());
                                                             }
                                                               :}
   | primary.p DOT IDENTIFIER.id LPAREN argument_list_opt.l RPAREN 
     {: return p.qualifiesAccess(new MethodAccess(l, id)); :}
   | SUPER DOT IDENTIFIER.id LPAREN argument_list_opt.l RPAREN
     {: return new SuperAccess("super").qualifiesAccess(new MethodAccess(l, id)); :}
   | name.n DOT SUPER DOT IDENTIFIER.id LPAREN argument_list_opt.l RPAREN
     {: return n.qualifiesAccess(new SuperAccess("super")).qualifiesAccess(new MethodAccess(l, id)); :}
   ;
Access array_access =
    name.n LBRACK expression.e RBRACK                 {: return n.qualifiesAccess(new ArrayAccess(e)); :}
  | primary_no_new_array.p LBRACK expression.e RBRACK {: return p.qualifiesAccess(new ArrayAccess(e)); :}
  | array_creation_init.a LBRACK expression.e RBRACK  {: return a.qualifiesAccess(new ArrayAccess(e)); :}
  ;
Expr postfix_expression =
    primary.p                                  {: return p; :}
  | name.n                                     {: return n; :}
  | postincrement_expression.e                 {: return e; :}
  | postdecrement_expression.e                 {: return e; :}
  ;
Expr postincrement_expression =
    postfix_expression.e PLUSPLUS              {: return new PostIncExpr(e); :}
  ;
Expr postdecrement_expression =
    postfix_expression.e MINUSMINUS            {: return new PostDecExpr(e); :}
  ;
Expr unary_expression =
    preincrement_expression.e                  {: return e; :}
  | predecrement_expression.e                  {: return e; :}
  | PLUS unary_expression.e                    {: return new PlusExpr(e); :}
  | MINUS unary_expression.e                   {: return new MinusExpr(e); :}
  | unary_expression_not_plus_minus.e          {: return e; :}
  ;
Expr preincrement_expression =
    PLUSPLUS unary_expression.e                {: return new PreIncExpr(e); :}
  ;
Expr predecrement_expression =
    MINUSMINUS unary_expression.e              {: return new PreDecExpr(e); :}
  ;
Expr unary_expression_not_plus_minus =
    postfix_expression.e                       {: return e; :}
  | COMP unary_expression.e                    {: return new BitNotExpr(e); :}
  | NOT unary_expression.e                     {: return new LogNotExpr(e); :}
  | cast_expression.e                          {: return e; :}
  ;
Expr cast_expression =
    LPAREN primitive_type.t dims.d RPAREN unary_expression.e      {: return new CastExpr(new ArrayTypeAccess(t, d.getNumChild()), e); :}
  | LPAREN primitive_type.t        RPAREN unary_expression.e      {: return new CastExpr(t, e); :}
  | LPAREN name.n dims.d RPAREN unary_expression_not_plus_minus.e {: return new CastExpr(new ArrayTypeAccess(n, d.getNumChild()), e); :}
  | LPAREN name.n        RPAREN unary_expression_not_plus_minus.e {: return new CastExpr(n, e); :}
  ;
Expr multiplicative_expression =
    unary_expression.e                                     {: return e; :}
  | multiplicative_expression.e1 MULT unary_expression.e2  {: return new MulExpr(e1, e2); :}
  | multiplicative_expression.e1 DIV unary_expression.e2   {: return new DivExpr(e1, e2); :}
  | multiplicative_expression.e1 MOD unary_expression.e2   {: return new ModExpr(e1, e2); :}
  ;
Expr additive_expression =
    multiplicative_expression.e                                {: return e; :}
  | additive_expression.e1 PLUS multiplicative_expression.e2   {: return new AddExpr(e1, e2); :}
  | additive_expression.e1 MINUS multiplicative_expression.e2  {: return new SubExpr(e1, e2); :}
  ;
Expr shift_expression =
    additive_expression.e                               {: return e; :}
  | shift_expression.e1 LSHIFT additive_expression.e2   {: return new LShiftExpr(e1, e2); :}
  | shift_expression.e1 RSHIFT additive_expression.e2   {: return new RShiftExpr(e1, e2); :}
  | shift_expression.e1 URSHIFT additive_expression.e2  {: return new URShiftExpr(e1, e2); :}
  ;
Expr relational_expression =
    shift_expression.e                                  {: return e; :}
  | relational_expression.e1 LT shift_expression.e2     {: return new LTExpr(e1, e2); :}
  | relational_expression.e1 GT shift_expression.e2     {: return new GTExpr(e1, e2); :}
  | relational_expression.e1 LTEQ shift_expression.e2   {: return new LEExpr(e1, e2); :}
  | relational_expression.e1 GTEQ shift_expression.e2   {: return new GEExpr(e1, e2); :}
  | relational_expression.e INSTANCEOF reference_type.t {: return new InstanceOfExpr(e, t); :}
  ;
Expr equality_expression =
    relational_expression.e                               {: return e; :}
  | equality_expression.e1 EQEQ relational_expression.e2  {: return new EQExpr(e1, e2); :}
  | equality_expression.e1 NOTEQ relational_expression.e2 {: return new NEExpr(e1, e2); :}
  ;
Expr and_expression =
    equality_expression.e                               {: return e; :}
  | and_expression.e1 AND equality_expression.e2        {: return new AndBitwiseExpr(e1, e2); :}
  ;
Expr exclusive_or_expression =
    and_expression.e                                    {: return e; :}
  | exclusive_or_expression.e1 XOR and_expression.e2    {: return new XorBitwiseExpr(e1, e2); :}
  ;
Expr inclusive_or_expression =
    exclusive_or_expression.e                                {: return e; :}
  | inclusive_or_expression.e1 OR exclusive_or_expression.e2 {: return new OrBitwiseExpr(e1, e2); :}
  ;
Expr conditional_and_expression =
    inclusive_or_expression.e                                       {: return e; :}
  | conditional_and_expression.e1 ANDAND inclusive_or_expression.e2 {: return new AndLogicalExpr(e1, e2); :}
  ;
Expr conditional_or_expression =
    conditional_and_expression.e                                    {: return e; :}
  | conditional_or_expression.e1 OROR conditional_and_expression.e2 {: return new OrLogicalExpr(e1, e2); :}
  ;
Expr conditional_expression =
    conditional_or_expression.c                                                        {: return c; :}
  | conditional_or_expression.c QUESTION expression.e1 COLON conditional_expression.e2 {: return new ConditionalExpr(c, e1, e2); :}
  ;
Expr assignment_expression =
    conditional_expression.c {: return c; :}
  | assignment.a {: return a; :}
  ;
Expr assignment =
    postfix_expression.dest assignment_operator.e assignment_expression.source {: e.setDest(dest); e.setSource(source); return e; :}
  ;
AssignExpr assignment_operator =
    EQ                                         {: return new AssignSimpleExpr(null, null); :}
  | MULTEQ                                     {: return new AssignMulExpr(null, null); :}
  | DIVEQ                                      {: return new AssignDivExpr(null, null); :}
  | MODEQ                                      {: return new AssignModExpr(null, null); :}
  | PLUSEQ                                     {: return new AssignPlusExpr(null, null); :}
  | MINUSEQ                                    {: return new AssignMinusExpr(null, null); :}
  | LSHIFTEQ                                   {: return new AssignLShiftExpr(null, null); :}
  | RSHIFTEQ                                   {: return new AssignRShiftExpr(null, null); :}
  | URSHIFTEQ                                  {: return new AssignURShiftExpr(null, null); :}
  | ANDEQ                                      {: return new AssignAndExpr(null, null); :}
  | XOREQ                                      {: return new AssignXorExpr(null, null); :}
  | OREQ                                       {: return new AssignOrExpr(null, null); :}
  ;
Expr expression =
    assignment_expression.a                    {: return a; :}
  ;
Expr constant_expression =
    expression.e                               {: return e; :}
  ;    
