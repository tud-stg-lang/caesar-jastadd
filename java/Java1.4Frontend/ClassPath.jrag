import java.io.File;
import java.util.*;
import parser.*;
import beaver.*;

aspect ClassPath {
  syn String CompilationUnit.relativeName() = relativeName;
  syn String CompilationUnit.pathName() = pathName;
  syn boolean CompilationUnit.fromSource() = fromSource;

  // add a filename to the list of source files to process
  public void Program.addSourceFile(String name) {
    sourceFiles.addSourceFile(name);
  }

  // iterate over all source files and demand-loaded compilation units
  public Iterator Program.compilationUnitIterator() {
	  initPaths();
	  
	  return new Iterator() {
		  int index = 0;
		  public boolean hasNext() {
			  return index < getNumCompilationUnit() || !sourceFiles.isEmpty();
		  }
		  public Object next() {
			  if(getNumCompilationUnit() == index) {
				  String typename = (String)sourceFiles.keySet().iterator().next();
				  CompilationUnit u = getCompilationUnit(typename);
				  if (u == null) throw new Error("File " + typename + " not found");
				  addCompilationUnit(u);
				  getCompilationUnit(getNumCompilationUnit()-1);

			  }
			  return getCompilationUnit(index++);
		  }
		  public void remove() {
			  throw new UnsupportedOperationException();
		  }
	  };
  }
  
  // get the input stream for a compilation unit specified using
  // a canonical name. This is used by the bytecode reader to load
  // nested types
  public InputStream Program.getInputStream(String name) {
    initPaths();
    try {
      for(Iterator iter = classPath.iterator(); iter.hasNext(); ) {
        PathPart part = (PathPart)iter.next();
        if(part.selectCompilationUnit(name))
          return part.is;
      }
    }
    catch(IOException e) {
    }
    throw new Error("Could not find nested type " + name);
  }
    
  // load a compilation unit from disc using the following rules:
  //   1) specified on the command line
  //   2) class file not older than source file
  //   3) source file
  public CompilationUnit Program.getCompilationUnit(String name) {
	  initPaths();
	  try {
		  // Look for class files
		  if (sourceFiles.selectCompilationUnit(name))
			  return sourceFiles.getCompilationUnit();
		  
		  PathPart sourcePart = null, classPart = null;
		  // Look for compilation unit in the source paths:
		  for (Iterator iter = sourcePath.iterator(); iter.hasNext() && sourcePart == null; ) {
			  PathPart part = (PathPart)iter.next();
			  if(part.selectCompilationUnit(name))
				  sourcePart = part;
		  }
		  // Look for compilation unit in the class paths:
		  for (Iterator iter = classPath.iterator(); iter.hasNext() && classPart == null; ) {
			  PathPart part = (PathPart)iter.next();
			  if(part.selectCompilationUnit(name))
				  classPart = part;
		  }

		  if (classPart != null && sourcePart != null) { // CU found both in source path and classpath
			  return classPart.age >= sourcePart.age ? 
					  classPart.getCompilationUnit() : sourcePart.getCompilationUnit();
		  } else if(classPart != null) { 				// CU only found in classpath
			  return classPart.getCompilationUnit();
		  } else if(sourcePart != null) { 				// CU only found in source path
			  return sourcePart.getCompilationUnit();
		  }
		  return null;	// else
	  }
	  catch(IOException e) {  }
	  return null;
  }
  
  // is there a package named name on the path
  public boolean Program.isPackage(String name) {
    if(sourceFiles.hasPackage(name))
      return true;
    for(Iterator iter = classPath.iterator(); iter.hasNext(); ) {
      PathPart part = (PathPart)iter.next();
      if(part.hasPackage(name))
        return true;
    }
    for(Iterator iter = sourcePath.iterator(); iter.hasNext(); ) {
      PathPart part = (PathPart)iter.next();
      if(part.hasPackage(name))
        return true;
    }
    return false;
  }

  private String CompilationUnit.relativeName;
  private String CompilationUnit.pathName;
  private boolean CompilationUnit.fromSource;

  public void CompilationUnit.setRelativeName(String name) {
    relativeName = name;
  }
  public void CompilationUnit.setPathName(String name) {
    pathName = name;
  }
  public void CompilationUnit.setFromSource(boolean value) {
    fromSource = value;
  }

  private boolean Program.pathsInitialized = false;
  private java.util.ArrayList Program.classPath;
  private java.util.ArrayList Program.sourcePath;
  private FileNamesPart Program.sourceFiles = new FileNamesPart();

  public void Program.pushClassPath(String name) {
    PathPart part = PathPart.createSourcePath(name, this);
    if(part != null) {
      sourcePath.add(part);
      System.out.println("Pushing source path " + name);
    }
    else
      throw new Error("Could not push source path " + name);
    part = PathPart.createClassPath(name, this);
    if(part != null) {
      classPath.add(part);
      System.out.println("Pushing class path " + name);
    }
  }
  public void Program.popClassPath() {
    sourcePath.remove(sourcePath.size()-1);
    classPath.remove(classPath.size()-1);
  }

  public void Program.initPaths() {
    if(!pathsInitialized) {
      pathsInitialized = true;

      //System.err.println("Initializing class paths");
      
      ArrayList classPaths = new ArrayList();
      ArrayList sourcePaths = new ArrayList();
      
      String[] bootclasspaths;
      if(Program.hasValueForOption("-bootclasspath"))
        bootclasspaths = Program.getValueForOption("-bootclasspath").split(File.pathSeparator);
      else
        bootclasspaths = System.getProperty("sun.boot.class.path").split(File.pathSeparator);
      for(int i = 0; i < bootclasspaths.length; i++) {
        classPaths.add(bootclasspaths[i]);
        //System.err.println("Adding classpath " + bootclasspaths[i]);
      }
      
      String[] extdirs;
      if(Program.hasValueForOption("-extdirs"))
        extdirs = Program.getValueForOption("-extdirs").split(File.pathSeparator);
      else
        extdirs = System.getProperty("java.ext.dirs").split(File.pathSeparator);
      for(int i = 0; i < extdirs.length; i++) {
        classPaths.add(extdirs[i]);
        //System.err.println("Adding classpath " + extdirs[i]);
      }

      String[] userClasses = null;
      if(Program.hasValueForOption("-classpath"))
        userClasses = Program.getValueForOption("-classpath").split(File.pathSeparator);
      else {
        String s = System.getProperty("java.class.path");
        if(s != null && s.length() > 0)
          userClasses = s.split(File.pathSeparator);
        else
          userClasses = ".".split(File.pathSeparator);
      }
      if(!Program.hasValueForOption("-sourcepath")) {
        for(int i = 0; i < userClasses.length; i++) {
          classPaths.add(userClasses[i]);
          sourcePaths.add(userClasses[i]);
          //System.err.println("Adding classpath/sourcepath " + userClasses[i]);
        }
      }
      else {
        for(int i = 0; i < userClasses.length; i++) {
          classPaths.add(userClasses[i]);
          //System.err.println("Adding classpath " + userClasses[i]);
        }
        userClasses = Program.getValueForOption("-sourcepath").split(File.pathSeparator);
        for(int i = 0; i < userClasses.length; i++) {
          sourcePaths.add(userClasses[i]);
          //System.err.println("Adding sourcepath " + userClasses[i]);
        }
      }
        
      classPath = new ArrayList();
      sourcePath = new ArrayList();
      
      for(Iterator iter = classPaths.iterator(); iter.hasNext(); ) {
        String s = (String)iter.next();
        PathPart part = PathPart.createClassPath(s, this);
        if(part != null) {
          classPath.add(part);
          //System.out.println("Adding classpath " + s);
        }
        else if(Program.verbose())
          System.out.println("Warning: Could not use " + s + " as class path");
      }
      for(Iterator iter = sourcePaths.iterator(); iter.hasNext(); ) {
        String s = (String)iter.next();
        PathPart part = PathPart.createSourcePath(s, this);
        if(part != null) {
          sourcePath.add(part);
          //System.out.println("Adding sourcepath " + s);
        }
        else if(Program.verbose())
          System.out.println("Warning: Could not use " + s + " as source path");
      }
    }
  }
    
  class PathPart {
    public InputStream is;
    protected String pathName; 
    protected String relativeName;
    protected String fullName;
    long age;
    Program program;
    
    private static parser.JavaParser parser = new parser.JavaParser();
    public static parser.JavaParser parser() { return parser; }
    
    protected PathPart() {
    }

    protected boolean isSource;
    protected String fileSuffix() {
      return isSource ? ".java" : ".class";
    }
    protected String cjFileSuffix() {
      return isSource ? ".java" : ".cjclass";
    }

    public static PathPart createSourcePath(String fileName, Program program) {
      PathPart p = createPathPart(fileName);
      if(p != null) {
        p.isSource = true;
        p.program = program;
      }
      return p;
    }

    public static PathPart createClassPath(String fileName, Program program) {
      PathPart p = createPathPart(fileName);
      if(p != null) {
        p.isSource = false;
        p.program = program;
      }
      return p;
    }

    private static PathPart createPathPart(String s) {
      try {
        File f = new File(s);
        if(f.isDirectory())
          return new FolderPart(f);
        else if(f.isFile())
          return new ZipFilePart(new ZipFile(f));
      } catch (IOException e) {
        // error in path
      }
      return null;
    }

    // is there a package with the specified name on this path part
    public boolean hasPackage(String name) { return false; }
    
    // select a compilation unit from a canonical name
    // returns true of the compilation unit exists on this path
    public boolean selectCompilationUnit(String canonicalName) throws IOException { return false; }

    // load the return currently selected compilation unit
    public CompilationUnit getCompilationUnit() {
      long startTime = System.currentTimeMillis();
      if(!isSource) {
        try {
          if(Program.verbose())
            System.out.print("Loading .class file: " + fullName + " ");
          CompilationUnit u = new org.caesarj.bytecode.Parser(is, fullName).parse(null, null, program);
          u.setPathName(pathName);
          u.setRelativeName(relativeName);
          u.setFromSource(false);
          
          // Avoid double closing of input stream!!!
          //is.close();
          //is = null;
          
          if(Program.verbose())
            System.out.println("in " + (System.currentTimeMillis() - startTime) + " ms");
          return u;
        } catch (Exception e) {
          throw new Error("Error loading " + fullName, e);
        }
      } 
      else {
        try {  
          if(Program.verbose())
            System.out.print("Loading .java file: " + fullName + " ");
            
          parser.JavaScanner scanner = new parser.JavaScanner(new parser.Unicode(is));
          CompilationUnit u = (CompilationUnit)parser.parse(scanner);
          is.close();
          is = null;
        
          u.setPathName(pathName);
          u.setRelativeName(relativeName);
          u.setFromSource(true);
          
          if(Program.verbose())
            System.out.println("in " + (System.currentTimeMillis() - startTime) + " ms");
          return u;
        } catch (JavaParser.SourceError e) {
          throw new JavaParser.SourceError(pathName + relativeName + ": " + e.getMessage());
        } catch (Exception e) {
          throw new Error(fullName + ": " + e.getMessage(), e);
        }
      }
    }
  }

  // load files from a folder
  class FolderPart extends PathPart {
    private HashMap map = new HashMap();
    private File folder;

    public FolderPart(File folder) {
      this.folder = folder;
    }

    public boolean hasPackage(String name) {
      return filesInPackage(name) != null;
    }

    public boolean hasCompilationUnit(String canonicalName) {
      int index = canonicalName.lastIndexOf('.');
      String packageName = index == -1 ? "" : canonicalName.substring(0, index);
      String typeName = canonicalName.substring(index + 1, canonicalName.length());
      Collection c = filesInPackage(packageName);
      return c != null && (c.contains(typeName + fileSuffix()) || c.contains(typeName + cjFileSuffix()));
    }
    
    private Collection filesInPackage(String packageName) {
    	if(!map.containsKey(packageName)) {
    		File f = new File(folder, packageName.replace('.', File.separatorChar));
    		Collection c = Collections.EMPTY_LIST;
    		if(f.exists() && f.isDirectory()) {
    			String[] files = f.list();
    			if(files.length > 0) {
    				c = new HashSet();
    				for(int i = 0; i < files.length; i++)
    					c.add(files[i]);
    			}
    		}
    		else
    			c = null;
    		map.put(packageName, c);
    	}
    	return (Collection)map.get(packageName);
    }
    
    public boolean selectCompilationUnit(String canonicalName) throws IOException {
    	if(hasCompilationUnit(canonicalName)) {
    		String fileName = canonicalName.replace('.', File.separatorChar);
    		if (new File(folder, fileName + fileSuffix()).isFile()
    		    && new File(folder, fileName + cjFileSuffix()).isFile()) {
    		  throw new Error(String.format(
    		    "The folder %s contains duplicate type %s in %s and in %s files",
    		    folder.getCanonicalPath(), canonicalName, fileName, fileSuffix()));
    		}
    		String fs = fileSuffix();
    		File classFile = new File(folder, fileName + fs); 	// try getting .java/.class file
    		if (!classFile.isFile()) {
    			fs = cjFileSuffix();
    			classFile = new File(folder, fileName + fs);	// try again with .cjclass extension
    		}
    		if(classFile.isFile()) {
    			is = new FileInputStream(classFile);
    			age = classFile.lastModified();
    			pathName = classFile.getPath();
    			relativeName = fileName + fs;
    			fullName = canonicalName;
    			return true;
    		}
    	}
    	return false;
    }
  }
  
  
  // load files in a zip file
  class ZipFilePart extends PathPart {
    private HashSet set = new HashSet();
    private ZipFile file;

    public boolean hasPackage(String name) {
      return set.contains(name);
    }

    public ZipFilePart(ZipFile file) {
      this.file = file;
      // process all entries in the zip file
      for (Enumeration e = file.entries() ; e.hasMoreElements() ;) {
        ZipEntry entry = (ZipEntry)e.nextElement();
        String pathName = new File(entry.getName()).getParent();
        if(pathName != null)
          pathName = pathName.replace(File.separatorChar, '.');
        if(!set.contains(pathName)) {
          int pos = 0;
          while(pathName != null && -1 != (pos = pathName.indexOf('.', pos + 1))) {
            String n = pathName.substring(0, pos);
            if(!set.contains(n)) {
              set.add(n);
            }
          }
          set.add(pathName);
        }
        set.add(entry.getName());
      }
    }

    public boolean selectCompilationUnit(String canonicalName) throws IOException {
    	String name = canonicalName.replace('.', '/'); // ZipFiles do always use '/' as separator
        if (set.contains(name + fileSuffix())
            && set.contains(name + cjFileSuffix())) {
          throw new Error(String.format(
            "The archive file %s contains duplicate type %s in %s and in %s files",
            file.getName(), name, fileSuffix(), cjFileSuffix()));
        }
    	String nameWithExt = name + fileSuffix();
    	if(set.contains(nameWithExt)) {
    		ZipEntry zipEntry = file.getEntry(nameWithExt);
    		if(zipEntry != null && !zipEntry.isDirectory()) {
    			is = file.getInputStream(zipEntry);
    			age = zipEntry.getTime();
    			pathName = file.getName();
    			relativeName = nameWithExt + fileSuffix();
    			fullName = canonicalName;
    			return true;
    		}
    	} else if (set.contains(name + cjFileSuffix())) {
    		// TODO refactor the whole fileSuffix() thing to accomodate CaesarJ binaries
    		
    		nameWithExt = name + cjFileSuffix();
    		ZipEntry zipEntry = file.getEntry(nameWithExt);
    		if(zipEntry != null && !zipEntry.isDirectory()) {
    			is = file.getInputStream(zipEntry);
    			age = zipEntry.getTime();
    			pathName = file.getName();
    			relativeName = nameWithExt + cjFileSuffix();
    			fullName = canonicalName;
    			return true;    	  
    		}
    	}
    	return false;
    }
  }
  
  // load files specified explicitly (on the command line)
  class FileNamesPart extends PathPart {
    private HashMap sourceFiles = new HashMap();
    private HashSet packages = new HashSet();

    public FileNamesPart() {
      isSource = true;
    }

    public boolean hasPackage(String name) { return packages.contains(name); }
    public boolean isEmpty() { return sourceFiles.isEmpty(); }
    public Collection keySet() { return sourceFiles.keySet(); }

    public boolean selectCompilationUnit(String canonicalName) throws IOException {
      if(sourceFiles.containsKey(canonicalName)) {
        String f = (String)sourceFiles.get(canonicalName);
        File classFile = new File(f);
        if(classFile.isFile()) {
          is = new FileInputStream(classFile); // make class file contents available through input stream
          pathName = "";
          relativeName = f;
          fullName = canonicalName;
          sourceFiles.remove(canonicalName);
          return true;
        }
      }
      return false;
    }
    public void addSourceFile(String name) {
      String canonicalName = canonicalName(name);
      sourceFiles.put(canonicalName, name);
      String pathName = canonicalName;
      if(!packages.contains(pathName)) {
        int pos = 0;
        while(pathName != null && -1 != (pos = pathName.indexOf('.', pos + 1))) {
          String n = pathName.substring(0, pos);
          if(!packages.contains(n))
            packages.add(n);
        }
      }
    }
    private static String canonicalName(String fileName) {
      try {
        Reader reader = new FileReader(fileName);
        JavaScanner scanner = new JavaScanner(new Unicode(reader));
        StringBuffer packageName = new StringBuffer();
        Symbol sym = scanner.nextToken();
        if(sym.getId() == JavaParser.Terminals.PACKAGE) {
          while(true) {
            sym = scanner.nextToken();
            if(sym.getId() == JavaParser.Terminals.SEMICOLON)
              break;
            packageName.append(sym.value);
          }
        }
        reader.close();
        if(packageName.length() != 0)
          packageName.append(".");
        int begin = fileName.lastIndexOf(File.separatorChar);
        begin = begin + 1;
       int end = fileName.lastIndexOf('.');
        packageName.append(fileName.substring(begin, end));
        return packageName.toString();
      } catch (Exception e) {
      }
      return fileName;
    }
  }

  // remove user defined classes from this program but keep library classes
  public void Program.simpleReset() {
    lookupType_String_String_values = new HashMap();
    hasPackage_String_values = new HashMap();
    List list = new List();
    for(int i = 0; i < getNumCompilationUnit(); i++) {
      String p = getCompilationUnit(i).packageName();
      if(p.startsWith("java") || p.startsWith(PRIMITIVE_PACKAGE_NAME))
        list.add(getCompilationUnit(i));
    }
    setCompilationUnitList(list);
  }
}
